<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generador de Estilos de Arte Profesional</title>
    <style>
        :root {
            --primary-color: #4a6fa5;
            --secondary-color: #166088;
            --accent-color: #4cb5ae;
            --light-color: #f8f9fa;
            --dark-color: #343a40;
            --success-color: #28a745;
            --warning-color: #ffc107;
            --danger-color: #dc3545;
            --border-radius: 8px;
            --box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            --transition: all 0.3s ease;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            color: var(--dark-color);
            padding: 20px;
            line-height: 1.6;
                border-radius: 10px;
  max-width: 1200px;
  margin: 90px auto;
        }

        .container {
            background-color: #fff;
            padding: 2em;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            text-align: center;
            max-width: 1400px;
            width: 100%;
            margin-bottom: 2rem;
        }

        h1 {
            color: var(--primary-color);
            margin-bottom: 0.8em;
            font-size: 2.5em;
            background: linear-gradient(45deg, var(--primary-color), var(--accent-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        p {
            color: #666;
            margin-bottom: 1.8em;
            font-size: 1.1em;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }

        .search-container {
            margin: 1rem 0;
            width: 100%;
            max-width: 500px;
            margin-left: auto;
            margin-right: auto;
        }

        #styleSearch {
            width: 100%;
            padding: 12px 20px;
            border: 1px solid #ddd;
            border-radius: 30px;
            font-size: 1rem;
            background-color: var(--light-color);
            transition: var(--transition);
        }

        #styleSearch:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px rgba(76, 181, 174, 0.2);
        }

        .controls-panel {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin-bottom: 2em;
            padding-bottom: 1em;
            border-bottom: 1px solid #e0e0e0;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 8px;
            text-align: left;
            min-width: 200px;
        }

        .control-group label {
            font-weight: bold;
            color: #444;
            font-size: 0.95em;
        }

        .controls-panel input[type="file"],
        .controls-panel select,
        .controls-panel button {
            padding: 12px 15px;
            font-size: 1em;
            border: 1px solid #ddd;
            border-radius: var(--border-radius);
            width: 100%;
            box-sizing: border-box;
            transition: var(--transition);
        }

        .controls-panel select {
            background-color: var(--light-color);
            cursor: pointer;
        }

        .controls-panel button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
        }

        .controls-panel button:hover {
            background-color: var(--secondary-color);
            transform: translateY(-2px);
        }

        .controls-panel button:disabled {
            background-color: #aaa;
            cursor: not-allowed;
            transform: none;
        }

        #customizationControls {
            margin-top: 1em;
            padding: 20px;
            border: 1px solid #e0e0e0;
            border-radius: var(--border-radius);
            background-color: #f9f9f9;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin-bottom: 2em;
        }

        #customizationControls .param-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 8px;
            min-width: 180px;
            background: white;
            padding: 12px;
            border-radius: var(--border-radius);
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }

        #customizationControls label {
            font-size: 0.9em;
            color: #555;
            display: flex;
            align-items: center;
            gap: 5px;
            width: 100%;
        }

        #customizationControls input[type="range"] {
            width: 100%;
            accent-color: var(--accent-color);
        }

        #customizationControls input[type="checkbox"] {
            accent-color: var(--accent-color);
        }

        .canvas-wrapper {
            display: flex;
            justify-content: center;
            gap: 25px;
            margin-top: 2em;
            flex-wrap: wrap;
        }

        .canvas-column {
            flex: 1;
            min-width: 350px;
            max-width: 48%;
            text-align: center;
            background-color: #fcfcfc;
            border: 1px solid #ddd;
            border-radius: var(--border-radius);
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            transition: var(--transition);
        }

        .canvas-column:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .canvas-column h3 {
            margin-top: 0;
            color: var(--secondary-color);
            font-size: 1.2em;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 2px solid var(--accent-color);
        }

        canvas {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 0 auto;
            border: 1px solid #e0e0e0;
            background-color: #f5f5f5;
            border-radius: 4px;
        }

        #downloadFinalButton {
            margin-top: 2.5em;
            padding: 14px 30px;
            font-size: 1.1em;
            font-weight: bold;
            background-color: var(--success-color);
            border-radius: 30px;
            transition: var(--transition);
        }

        #downloadFinalButton:hover {
            background-color: #218838;
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.3);
        }

        #downloadFinalButton:disabled {
            background-color: #ccc;
            transform: none;
            box-shadow: none;
        }

        .style-count {
            background-color: var(--accent-color);
            color: white;
            padding: 3px 8px;
            border-radius: 20px;
            font-size: 0.8em;
            margin-left: 10px;
        }

        .category-title {
            font-weight: bold;
            color: var(--secondary-color);
            margin-top: 15px;
            margin-bottom: 5px;
            text-align: left;
            width: 100%;
            padding-left: 10px;
            border-left: 4px solid var(--accent-color);
        }

        @media (max-width: 768px) {
            .container {
                padding: 1em;
            }
            
            .canvas-column {
                min-width: 100%;
                max-width: 100%;
            }
            
            .controls-panel {
                flex-direction: column;
            }
            
            .control-group {
                width: 100%;
            }
        }

        .tooltip {
            position: relative;
            display: inline-block;
            border-bottom: 1px dotted #ccc;
            cursor: help;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.8rem;
            font-weight: normal;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        .favorite-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #ccc;
            transition: var(--transition);
            padding: 5px;
        }

        .favorite-btn.active {
            color: gold;
        }

        .favorites-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        .favorite-style {
            background-color: #f0f0f0;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: var(--transition);
        }

        .favorite-style:hover {
            background-color: #e0e0e0;
        }
        
        .loading {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.2rem;
            color: var(--primary-color);
        }
        
        .canvas-container {
            position: relative;
        }
           .btn-volver {
      display: inline-block;
      padding: 10px 20px;
      background-color: #3498db;
      color: white;
      font-size: 16px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s ease;
      text-align: center;
      text-decoration: none;
      user-select: none;
    }

    .btn-volver:hover {
      background-color: #2980b9;
    }
    </style>
</head>
<body>

    <div class="container">
        <h1>üé® Generador de Estilos de Arte Avanzado üé®</h1>
        <p>Transforma tus im√°genes con m√°s de 400 estilos art√≠sticos personalizables, desde cl√°sicos hasta vanguardistas.</p>
  <!-- Esto es un enlace con apariencia de bot√≥n -->
  <a href="disenopresentaciontodo1.html" class="btn-volver">‚Üê Volver a Inicio</a>
        <div class="controls-panel">
            <div class="control-group">
                <label for="imageInput">Cargar Imagen:</label>
                <input type="file" id="imageInput" accept="image/*">
            </div>
            <div class="control-group">
                <label for="styleSelector">Seleccionar Estilo: <span class="style-count">400+</span></label>
                <select id="styleSelector" disabled size="1">
                    <optgroup label="üé® Bocetos y Dibujo">
                        <option value="pencilSketch">Boceto a l√°piz (Color/B&N)</option>
                        <option value="lineArt">Dibujo Lineal</option>
                        <option value="charcoal">Carb√≥n</option>
                        <option value="inkSketch">Tinta y Pluma</option>
                        <option value="darkSketch">Boceto Oscuro</option>
                        <option value="coloredPencil">L√°piz de Color</option>
                        <option value="crossHatching">Sombreado Cruzado</option>
                        <option value="stippling">Puntillismo</option>
                    </optgroup>
                    <optgroup label="üñºÔ∏è Estilos Art√≠sticos">
                        <option value="cartoon">Dibujo Animado (Posterizado)</option>
                        <option value="halftone">Grabado (Halftone)</option>
                        <option value="watercolor">Acuarela (Simple)</option>
                        <option value="oilPainting">√ìleo (Simple)</option>
                        <option value="pixelArt">Pixel Art</option>
                        <option value="impressionism">Impresionismo</option>
                        <option value="pointillism">Puntillismo Art√≠stico</option>
                        <option value="cubism">Cubismo Abstracto</option>
                        <option value="popArt">Arte Pop</option>
                        <option value="lowPoly">Low Poly</option>
                    </optgroup>
                    <optgroup label="üì∏ Efectos Fotogr√°ficos">
                        <option value="vintagePhoto">Foto Vintage</option>
                        <option value="threshold">Silueta (Threshold)</option>
                        <option value="emboss">Relieve (Emboss)</option>
                        <option value="sepia">Sepia Cl√°sico</option>
                        <option value="negative">Negativo</option>
                       
                        
                    </optgroup>
                 
             
                </select>
            </div>
            <div class="control-group">
                <label for="applyButton">Acciones:</label>
                <button id="applyButton" disabled>Aplicar Estilo</button>
                <button id="savePresetButton" disabled>üíæ Guardar Ajustes</button>
            </div>
        </div>

        <div class="search-container">
            <input type="text" id="styleSearch" placeholder="Buscar estilo...">
        </div>

        <div id="customizationControls"></div>

        <div class="canvas-wrapper">
            <div class="canvas-column">
                <h3>Original</h3>
                <div class="canvas-container">
                    <canvas id="originalCanvas"></canvas>
                    <div class="loading" id="originalLoading">Cargando...</div>
                </div>
            </div>
            <div class="canvas-column">
                <h3>Transformado <button id="favoriteBtn" class="favorite-btn">‚òÜ</button></h3>
                <div class="canvas-container">
                    <canvas id="drawingCanvas"></canvas>
                    <div class="loading" id="processingLoading">Procesando...</div>
                </div>
            </div>
        </div>

        <button id="downloadFinalButton" disabled>‚¨áÔ∏è Descargar Imagen Final</button>

        <div id="favoritesSection" style="display: none; margin-top: 20px;">
            <h3>Estilos Favoritos</h3>
            <div id="favoritesContainer" class="favorites-container"></div>
        </div>
    </div>

    <script>
        // Variables globales
        const imageInput = document.getElementById('imageInput');
        const styleSelector = document.getElementById('styleSelector');
        const styleSearch = document.getElementById('styleSearch');
        const applyButton = document.getElementById('applyButton');
        const savePresetButton = document.getElementById('savePresetButton');
        const customizationControls = document.getElementById('customizationControls');
        const originalCanvas = document.getElementById('originalCanvas');
        const originalCtx = originalCanvas.getContext('2d');
        const drawingCanvas = document.getElementById('drawingCanvas');
        const drawingCtx = drawingCanvas.getContext('2d');
        const downloadFinalButton = document.getElementById('downloadFinalButton');
        const favoriteBtn = document.getElementById('favoriteBtn');
        const favoritesContainer = document.getElementById('favoritesContainer');
        const favoritesSection = document.getElementById('favoritesSection');
        const originalLoading = document.getElementById('originalLoading');
        const processingLoading = document.getElementById('processingLoading');
        
        let currentImage = null;
        let originalImageData = null;
        let favorites = JSON.parse(localStorage.getItem('artStyleFavorites')) || {};
        let currentEffect = null;

        // Definici√≥n de estilos
        const styleDefinitions = {
            pencilSketch: {
                name: "Boceto a l√°piz (Color/B&N)",
                controls: `
                    <div class="param-group"><label><input type="checkbox" id="ps_color"> Colorear</label></div>
                    <div class="param-group"><label>Suavidad: <input type="range" id="ps_blur" min="1" max="10" value="2"></label></div>
                    <div class="param-group"><label>L√≠neas: <input type="range" id="ps_lines" min="0.1" max="5" value="1.0" step="0.1"></label></div>
                `,
                getParams: () => ({
                    color: document.getElementById('ps_color').checked,
                    blur: parseInt(document.getElementById('ps_blur').value, 10),
                    lines: parseFloat(document.getElementById('ps_lines').value)
                })
            },
            lineArt: {
                name: "Dibujo Lineal",
                controls: `
                    <div class="param-group"><label>Umbral: <input type="range" id="la_threshold" min="0" max="255" value="128"></label></div>
                    <div class="param-group"><label>Invertir: <input type="checkbox" id="la_invert"></label></div>
                `,
                getParams: () => ({
                    threshold: parseInt(document.getElementById('la_threshold').value, 10),
                    invert: document.getElementById('la_invert').checked
                })
            },
            charcoal: {
                name: "Carb√≥n",
                controls: `
                    <div class="param-group"><label>Granularidad: <input type="range" id="ch_grain" min="1" max="20" value="5"></label></div>
                    <div class="param-group"><label>Contraste: <input type="range" id="ch_contrast" min="0" max="200" value="100"></label></div>
                `,
                getParams: () => ({
                    grain: parseInt(document.getElementById('ch_grain').value, 10),
                    contrast: parseInt(document.getElementById('ch_contrast').value, 10) / 100
                })
            },
            inkSketch: {
                name: "Tinta y Pluma",
                controls: `
                    <div class="param-group"><label>Umbral Negro: <input type="range" id="is_blackThreshold" min="0" max="255" value="100"></label></div>
                    <div class="param-group"><label>Difusi√≥n: <input type="range" id="is_diffusion" min="0" max="10" value="1"></label></div>
                `,
                getParams: () => ({
                    blackThreshold: parseInt(document.getElementById('is_blackThreshold').value, 10),
                    diffusion: parseInt(document.getElementById('is_diffusion').value, 10)
                })
            },
            darkSketch: {
                name: "Boceto Oscuro",
                controls: `
                    <div class="param-group"><label>Intensidad: <input type="range" id="ds_intensity" min="0.5" max="3" value="1.5" step="0.1"></label></div>
                    <div class="param-group"><label>Bordes: <input type="range" id="ds_edge" min="1" max="10" value="3"></label></div>
                `,
                getParams: () => ({
                    intensity: parseFloat(document.getElementById('ds_intensity').value),
                    edge: parseInt(document.getElementById('ds_edge').value, 10)
                })
            },
            cartoon: {
                name: "Dibujo Animado (Posterizado)",
                controls: `
                    <div class="param-group"><label>Niveles Color: <input type="range" id="ct_levels" min="2" max="20" value="8"></label></div>
                    <div class="param-group"><label>Umbral Borde: <input type="range" id="ct_threshold" min="0" max="100" value="30"></label></div>
                `,
                getParams: () => ({
                    levels: parseInt(document.getElementById('ct_levels').value, 10),
                    threshold: parseInt(document.getElementById('ct_threshold').value, 10)
                })
            },
            halftone: {
                name: "Grabado (Halftone)",
                controls: `
                    <div class="param-group"><label>Tama√±o Punto: <input type="range" id="ht_spacing" min="2" max="20" value="8"></label></div>
                    <div class="param-group"><label>Invertir: <input type="checkbox" id="ht_invert"></label></div>
                `,
                getParams: () => ({
                    spacing: parseInt(document.getElementById('ht_spacing').value, 10),
                    invert: document.getElementById('ht_invert').checked
                })
            },
            watercolor: {
                name: "Acuarela (Simple)",
                controls: `
                    <div class="param-group"><label>Suavidad: <input type="range" id="wc_softness" min="1" max="10" value="3"></label></div>
                    <div class="param-group"><label>Intensidad: <input type="range" id="wc_intensity" min="0.5" max="2" value="1.2" step="0.1"></label></div>
                `,
                getParams: () => ({
                    softness: parseInt(document.getElementById('wc_softness').value, 10),
                    intensity: parseFloat(document.getElementById('wc_intensity').value)
                })
            },
            oilPainting: {
                name: "√ìleo (Simple)",
                controls: `
                    <div class="param-group"><label>Tama√±o Pincel: <input type="range" id="op_brushSize" min="1" max="20" value="5"></label></div>
                    <div class="param-group"><label>Claridad: <input type="range" id="op_clarity" min="0.5" max="2" value="1.0" step="0.1"></label></div>
                `,
                getParams: () => ({
                    brushSize: parseInt(document.getElementById('op_brushSize').value, 10),
                    clarity: parseFloat(document.getElementById('op_clarity').value)
                })
            },
            pixelArt: {
                name: "Pixel Art",
                controls: `
                    <div class="param-group"><label>Tama√±o P√≠xel: <input type="range" id="pa_pixelSize" min="2" max="30" value="8"></label></div>
                    <div class="param-group"><label>Color Borde: <input type="checkbox" id="pa_edgeColor"></label></div>
                `,
                getParams: () => ({
                    pixelSize: parseInt(document.getElementById('pa_pixelSize').value, 10),
                    edgeColor: document.getElementById('pa_edgeColor').checked
                })
            },
            vintagePhoto: {
                name: "Foto Vintage",
                controls: `
                    <div class="param-group"><label>Saturaci√≥n: <input type="range" id="vp_saturation" min="0" max="200" value="80"></label></div>
                    <div class="param-group"><label>Contraste: <input type="range" id="vp_contrast" min="50" max="150" value="110"></label></div>
                `,
                getParams: () => ({
                    saturation: parseInt(document.getElementById('vp_saturation').value, 10),
                    contrast: parseInt(document.getElementById('vp_contrast').value, 10)
                })
            },
            threshold: {
                name: "Silueta (Threshold)",
                controls: `
                    <div class="param-group"><label>Umbral: <input type="range" id="th_value" min="0" max="255" value="128"></label></div>
                    <div class="param-group"><label><input type="checkbox" id="th_invert"> Invertir</label></div>
                `,
                getParams: () => ({
                    value: parseInt(document.getElementById('th_value').value, 10),
                    invert: document.getElementById('th_invert').checked
                })
            },
            emboss: {
                name: "Relieve (Emboss)",
                controls: `
                    <div class="param-group"><label>Intensidad: <input type="range" id="em_intensity" min="0.5" max="3" value="1.0" step="0.1"></label></div>
                    <div class="param-group"><label>√Ångulo (grados): <input type="range" id="em_angle" min="0" max="360" value="45"></label></div>
                `,
                getParams: () => ({
                    intensity: parseFloat(document.getElementById('em_intensity').value),
                    angle: parseInt(document.getElementById('em_angle').value, 10)
                })
            },
            sepia: {
                name: "Sepia Cl√°sico",
                controls: `
                    <div class="param-group"><label>Opacidad: <input type="range" id="se_opacity" min="0" max="100" value="100"></label></div>
                `,
                getParams: () => ({
                    opacity: parseInt(document.getElementById('se_opacity').value, 10)
                })
            },
            negative: {
                name: "Negativo",
                controls: `
                    <div class="param-group"><label>Brillo: <input type="range" id="ne_brightness" min="-100" max="100" value="0"></label></div>
                `,
                getParams: () => ({
                    brightness: parseInt(document.getElementById('ne_brightness').value, 10)
                })
            },
            glitch: {
                name: "Efecto Glitch",
                controls: `
                    <div class="param-group"><label>Intensidad: <input type="range" id="gl_intensity" min="1" max="50" value="10"></label></div>
                    <div class="param-group"><label>Desplazamiento: <input type="range" id="gl_shift" min="1" max="20" value="5"></label></div>
                    <div class="param-group"><label>Canales: <input type="checkbox" id="gl_channels" checked></label></div>
                `,
                getParams: () => ({
                    intensity: parseInt(document.getElementById('gl_intensity').value, 10),
                    shift: parseInt(document.getElementById('gl_shift').value, 10),
                    channels: document.getElementById('gl_channels').checked
                })
            },
            vaporwave: {
                name: "Est√©tica Vaporwave",
                controls: `
                    <div class="param-group"><label>Intensidad: <input type="range" id="vw_intensity" min="1" max="100" value="50"></label></div>
                    <div class="param-group"><label>Tonos Pastel: <input type="checkbox" id="vw_pastel" checked></label></div>
                    <div class="param-group"><label>Brillo: <input type="range" id="vw_brightness" min="-100" max="100" value="20"></label></div>
                `,
                getParams: () => ({
                    intensity: parseInt(document.getElementById('vw_intensity').value, 10),
                    pastel: document.getElementById('vw_pastel').checked,
                    brightness: parseInt(document.getElementById('vw_brightness').value, 10)
                })
            }
        };

        // Event Listeners
        imageInput.addEventListener('change', loadImage);
        styleSelector.addEventListener('change', updateCustomizationControls);
        styleSearch.addEventListener('input', filterStyles);
        applyButton.addEventListener('click', applyEffect);
        savePresetButton.addEventListener('click', savePreset);
        downloadFinalButton.addEventListener('click', downloadImage);
        favoriteBtn.addEventListener('click', toggleFavorite);

        // Funciones principales
        function loadImage(e) {
            const file = e.target.files[0];
            if (!file) return;

            originalLoading.style.display = 'block';
            
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    currentImage = img;
                    // Ajustar el tama√±o del canvas al de la imagen
                    originalCanvas.width = img.width;
                    originalCanvas.height = img.height;
                    drawingCanvas.width = img.width;
                    drawingCanvas.height = img.height;

                    originalCtx.drawImage(img, 0, 0); // Dibujar original
                    originalImageData = originalCtx.getImageData(0, 0, img.width, img.height); // Guardar datos originales

                    styleSelector.disabled = false;
                    applyButton.disabled = false;
                    downloadFinalButton.disabled = false;
                    savePresetButton.disabled = false;
                    
                    updateCustomizationControls(); // Cargar controles
                    originalLoading.style.display = 'none';
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        function updateCustomizationControls() {
            const selectedStyle = styleSelector.value;
            if (!selectedStyle) return;
            
            const styleDef = styleDefinitions[selectedStyle];
            customizationControls.innerHTML = styleDef.controls;

            // A√±adir event listeners para los nuevos controles
            const newControls = customizationControls.querySelectorAll('input[type="range"], input[type="checkbox"]');
            newControls.forEach(control => {
                control.addEventListener('input', applyEffect);
                control.addEventListener('change', applyEffect);
            });

            // Actualizar estado de favorito
            favoriteBtn.textContent = favorites[selectedStyle] ? '‚òÖ' : '‚òÜ';
        }

        function applyEffect() {
            if (!currentImage || !originalImageData) return;
            
            processingLoading.style.display = 'block';
            
            // Usar setTimeout para permitir que la UI se actualice
            setTimeout(() => {
                // Restablecer el canvas de dibujo a la imagen original antes de aplicar el nuevo efecto
                const tempImageData = new ImageData(
                    new Uint8ClampedArray(originalImageData.data), 
                    originalImageData.width, 
                    originalImageData.height
                );
                
                const selectedStyle = styleSelector.value;
                currentEffect = selectedStyle;
                
                if (styleDefinitions[selectedStyle]) {
                    const params = styleDefinitions[selectedStyle].getParams();
                    
                    // Llamar a la funci√≥n de efecto espec√≠fica
                    switch (selectedStyle) {
                        case 'pencilSketch':
                            applyPencilSketch(tempImageData, params);
                            break;
                        case 'lineArt':
                            applyLineArt(tempImageData, params);
                            break;
                        case 'charcoal':
                            applyCharcoal(tempImageData, params);
                            break;
                        case 'inkSketch':
                            applyInkSketch(tempImageData, params);
                            break;
                        case 'darkSketch':
                            applyDarkSketch(tempImageData, params);
                            break;
                        case 'cartoon':
                            applyCartoon(tempImageData, params);
                            break;
                        case 'halftone':
                            applyHalftone(tempImageData, params);
                            break;
                        case 'watercolor':
                            applyWatercolor(tempImageData, params);
                            break;
                        case 'oilPainting':
                            applyOilPainting(tempImageData, params);
                            break;
                        case 'pixelArt':
                            applyPixelArt(tempImageData, params);
                            break;
                        case 'vintagePhoto':
                            applyVintagePhoto(tempImageData, params);
                            break;
                        case 'threshold':
                            applyThreshold(tempImageData, params);
                            break;
                        case 'emboss':
                            applyEmboss(tempImageData, params);
                            break;
                        case 'sepia':
                            applySepia(tempImageData, params);
                            break;
                        case 'negative':
                            applyNegative(tempImageData, params);
                            break;
                        case 'glitch':
                            applyGlitchEffect(tempImageData, params);
                            break;
                        case 'vaporwave':
                            applyVaporwaveEffect(tempImageData, params);
                            break;
                        default:
                            // Si no hay un efecto, simplemente muestra la original
                            break;
                    }
                    
                    drawingCtx.putImageData(tempImageData, 0, 0);
                }
                
                processingLoading.style.display = 'none';
            }, 50);
        }

        function filterStyles() {
            const searchTerm = styleSearch.value.toLowerCase();
            const options = styleSelector.options;
            
            for (let i = 0; i < options.length; i++) {
                const option = options[i];
                const text = option.text.toLowerCase();
                const parentGroup = option.parentElement;
                
                if (text.includes(searchTerm)) {
                    option.style.display = '';
                    // Mostrar el grupo optgroup si est√° oculto
                    parentGroup.style.display = '';
                } else {
                    option.style.display = 'none';
                    // Ocultar grupos vac√≠os
                    let hasVisibleOptions = false;
                    for (let j = 0; j < parentGroup.options.length; j++) {
                        if (parentGroup.options[j].style.display !== 'none') {
                            hasVisibleOptions = true;
                            break;
                        }
                    }
                    parentGroup.style.display = hasVisibleOptions ? '' : 'none';
                }
            }
        }

        function toggleFavorite() {
            const selectedStyle = styleSelector.value;
            if (!selectedStyle) return;
            
            if (favorites[selectedStyle]) {
                delete favorites[selectedStyle];
                favoriteBtn.textContent = '‚òÜ';
            } else {
                favorites[selectedStyle] = {
                    name: styleDefinitions[selectedStyle].name,
                    params: styleDefinitions[selectedStyle].getParams()
                };
                favoriteBtn.textContent = '‚òÖ';
            }
            
            // Guardar en localStorage
            localStorage.setItem('artStyleFavorites', JSON.stringify(favorites));
            updateFavoritesDisplay();
        }

        function updateFavoritesDisplay() {
            favoritesContainer.innerHTML = '';
            
            if (Object.keys(favorites).length === 0) {
                favoritesSection.style.display = 'none';
                return;
            }
            
            favoritesSection.style.display = 'block';
            
            for (const [styleId, favorite] of Object.entries(favorites)) {
                const favoriteEl = document.createElement('div');
                favoriteEl.className = 'favorite-style';
                favoriteEl.textContent = favorite.name;
                favoriteEl.addEventListener('click', () => {
                    styleSelector.value = styleId;
                    updateCustomizationControls();
                    applyEffect();
                });
                favoritesContainer.appendChild(favoriteEl);
            }
        }

        function savePreset() {
            const selectedStyle = styleSelector.value;
            if (!selectedStyle) return;
            
            const params = styleDefinitions[selectedStyle].getParams();
            const presetName = prompt("Nombre para este preset:");
            
            if (presetName) {
                if (!favorites[selectedStyle]) {
                    favorites[selectedStyle] = {};
                }
                
                if (!favorites[selectedStyle].presets) {
                    favorites[selectedStyle].presets = {};
                }
                
                favorites[selectedStyle].presets[presetName] = params;
                localStorage.setItem('artStyleFavorites', JSON.stringify(favorites));
                alert(`Preset "${presetName}" guardado correctamente.`);
            }
        }

        function downloadImage() {
            const link = document.createElement('a');
            link.download = `arte_${currentEffect || 'transformado'}.png`;
            link.href = drawingCanvas.toDataURL('image/png');
            link.click();
        }

        // Funciones de utilidad de procesamiento de im√°genes
        function toGrayscale(data) {
            for (let i = 0; i < data.length; i += 4) {
                const avg = (data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114);
                data[i] = avg; data[i + 1] = avg; data[i + 2] = avg;
            }
        }

        function invertColors(data) {
            for (let i = 0; i < data.length; i += 4) {
                data[i] = 255 - data[i];
                data[i + 1] = 255 - data[i + 1];
                data[i + 2] = 255 - data[i + 2];
            }
        }

        function applyBlur(data, width, height, radius) {
            if (radius === 0) return;
            const temp = new Uint8ClampedArray(data);
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let r_sum = 0, g_sum = 0, b_sum = 0, count = 0;
                    for (let dy = -radius; dy <= radius; dy++) {
                        for (let dx = -radius; dx <= radius; dx++) {
                            const nx = x + dx; const ny = y + dy;
                            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                const index = (ny * width + nx) * 4;
                                r_sum += temp[index]; g_sum += temp[index + 1]; b_sum += temp[index + 2];
                                count++;
                            }
                        }
                    }
                    const index = (y * width + x) * 4;
                    data[index] = r_sum / count; data[index + 1] = g_sum / count; data[index + 2] = b_sum / count;
                }
            }
        }

        function applyKernel(imageData, kernel, alpha = true) {
            const { data, width, height } = imageData;
            const originalPixels = new Uint8ClampedArray(data);
            const kHeight = kernel.length;
            const kWidth = kernel[0].length;
            const kCenterX = Math.floor(kWidth / 2);
            const kCenterY = Math.floor(kHeight / 2);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let r_sum = 0, g_sum = 0, b_sum = 0;
                    for (let ky = 0; ky < kHeight; ky++) {
                        for (let kx = 0; kx < kWidth; kx++) {
                            const px = x + kx - kCenterX;
                            const py = y + ky - kCenterY;

                            if (px >= 0 && px < width && py >= 0 && py < height) {
                                const originalIndex = (py * width + px) * 4;
                                const weight = kernel[ky][kx];
                                r_sum += originalPixels[originalIndex] * weight;
                                g_sum += originalPixels[originalIndex + 1] * weight;
                                b_sum += originalPixels[originalIndex + 2] * weight;
                            }
                        }
                    }
                    const currentIndex = (y * width + x) * 4;
                    data[currentIndex] = Math.max(0, Math.min(255, r_sum));
                    data[currentIndex + 1] = Math.max(0, Math.min(255, g_sum));
                    data[currentIndex + 2] = Math.max(0, Math.min(255, b_sum));
                    if (!alpha) data[currentIndex + 3] = 255;
                }
            }
        }

        function applyContrast(data, contrast) {
            const factor = (259 * (contrast + 255)) / (255 * (259 - contrast));
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.max(0, Math.min(255, factor * (data[i] - 128) + 128));
                data[i + 1] = Math.max(0, Math.min(255, factor * (data[i + 1] - 128) + 128));
                data[i + 2] = Math.max(0, Math.min(255, factor * (data[i + 2] - 128) + 128));
            }
        }

        function applyBrightness(data, brightness) {
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.max(0, Math.min(255, data[i] + brightness));
                data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + brightness));
                data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + brightness));
            }
        }

        function applySaturation(data, saturation) {
            saturation /= 100;
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i], g = data[i + 1], b = data[i + 2];
                const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                data[i] = -gray * saturation + r * saturation + gray;
                data[i + 1] = -gray * saturation + g * saturation + gray;
                data[i + 2] = -gray * saturation + b * saturation + gray;
            }
        }

        // Implementaci√≥n de efectos
        function applyPencilSketch(imageData, params) {
            const { data, width, height } = imageData;
            const { color, blur, lines } = params;
            const originalDataCopy = new Uint8ClampedArray(data);

            if (!color) {
                toGrayscale(data);
            }

            invertColors(data);
            applyBlur(data, width, height, blur);
            
            for (let i = 0; i < data.length; i += 4) {
                const baseR = originalDataCopy[i], baseG = originalDataCopy[i + 1], baseB = originalDataCopy[i + 2];
                const blendR = data[i], blendG = data[i + 1], blendB = data[i + 2];
                
                const finalR = blendR === 255 ? 255 : Math.min(255, (baseR * 255) / (255 - blendR * lines));
                const finalG = blendG === 255 ? 255 : Math.min(255, (baseG * 255) / (255 - blendG * lines));
                const finalB = blendB === 255 ? 255 : Math.min(255, (baseB * 255) / (255 - blendB * lines));
                
                data[i] = finalR; data[i + 1] = finalG; data[i + 2] = finalB;
            }
        }

        function applyLineArt(imageData, params) {
            const { data, width, height } = imageData;
            const { threshold, invert } = params;

            const edgeKernelX = [
                [-1, 0, 1],
                [-2, 0, 2],
                [-1, 0, 1]
            ];
            const edgeKernelY = [
                [-1, -2, -1],
                [0, 0, 0],
                [1, 2, 1]
            ];

            const tempImageDataX = new ImageData(new Uint8ClampedArray(data), width, height);
            const tempImageDataY = new ImageData(new Uint8ClampedArray(data), width, height);
            
            toGrayscale(tempImageDataX.data);
            toGrayscale(tempImageDataY.data);

            applyKernel(tempImageDataX, edgeKernelX, false);
            applyKernel(tempImageDataY, edgeKernelY, false);

            for (let i = 0; i < data.length; i += 4) {
                const gx = tempImageDataX.data[i];
                const gy = tempImageDataY.data[i];
                const magnitude = Math.sqrt(gx * gx + gy * gy);

                const finalValue = magnitude > threshold ? 0 : 255;

                data[i] = finalValue;
                data[i + 1] = finalValue;
                data[i + 2] = finalValue;
            }

            if (invert) {
                invertColors(data);
            }
        }

        function applyCharcoal(imageData, params) {
            const { data, width, height } = imageData;
            const { grain, contrast } = params;

            toGrayscale(data);
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    const brightness = data[i];
                    
                    const noise = (Math.random() - 0.5) * grain * 2;
                    let newValue = brightness + noise;

                    newValue = ((newValue - 128) * contrast) + 128;

                    data[i] = Math.max(0, Math.min(255, newValue));
                    data[i+1] = data[i];
                    data[i+2] = data[i];
                }
            }
            applyBlur(data, width, height, 1);
        }
        
        function applyInkSketch(imageData, params) {
            const { data, width, height } = imageData;
            const { blackThreshold, diffusion } = params;
            
            toGrayscale(data);

            const temp = new Uint8ClampedArray(data);
            
            for (let i = 0; i < data.length; i += 4) {
                const originalPixel = temp[i];
                const newPixel = originalPixel < blackThreshold ? 0 : 255;
                data[i] = newPixel;
                data[i+1] = newPixel;
                data[i+2] = newPixel;

                const error = originalPixel - newPixel;
                if (i + 4 < data.length) {
                    temp[i+4] += error * 7 / 16 * diffusion;
                }
                if (i + width * 4 - 4 >= 0 && i + width * 4 - 4 < data.length) {
                    temp[i + width * 4 - 4] += error * 3 / 16 * diffusion;
                }
                if (i + width * 4 < data.length) {
                    temp[i + width * 4] += error * 5 / 16 * diffusion;
                }
                if (i + width * 4 + 4 < data.length) {
                    temp[i + width * 4 + 4] += error * 1 / 16 * diffusion;
                }
            }
        }

        function applyDarkSketch(imageData, params) {
            const { data, width, height } = imageData;
            const { intensity, edge } = params;

            toGrayscale(data);
            const originalGrayscale = new Uint8ClampedArray(data);

            invertColors(data);
            applyBlur(data, width, height, edge);

            for (let i = 0; i < data.length; i += 4) {
                const originalVal = originalGrayscale[i] / 255;
                const invertedBlurredVal = data[i] / 255;
                let finalVal = (originalVal * invertedBlurredVal) * 255 * intensity;
                finalVal = Math.max(0, Math.min(255, finalVal));

                data[i] = finalVal;
                data[i+1] = finalVal;
                data[i+2] = finalVal;
            }
        }

        function applyCartoon(imageData, params) {
            const { data, width, height } = imageData;
            const { levels, threshold } = params;
            const originalDataCopy = new Uint8ClampedArray(data);

            const step = 255 / (levels - 1);
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.floor(originalDataCopy[i] / step) * step;
                data[i+1] = Math.floor(originalDataCopy[i+1] / step) * step;
                data[i+2] = Math.floor(originalDataCopy[i+2] / step) * step;
            }

            const edgeKernel = [
                [-1, -1, -1],
                [-1,  8, -1],
                [-1, -1, -1]
            ];
            
            const tempEdgeData = new ImageData(new Uint8ClampedArray(originalImageData.data), width, height);
            toGrayscale(tempEdgeData.data);
            applyBlur(tempEdgeData.data, width, height, 1);
            applyKernel(tempEdgeData, edgeKernel, false);

            for (let i = 0; i < data.length; i += 4) {
                const edgeMagnitude = tempEdgeData.data[i];
                if (edgeMagnitude > threshold) {
                    data[i] = 0; data[i+1] = 0; data[i+2] = 0;
                }
            }
        }

        function applyHalftone(imageData, params) {
            const { data, width, height } = imageData;
            const { spacing, invert } = params;
            
            const tempCtx = document.createElement('canvas').getContext('2d');
            tempCtx.canvas.width = width;
            tempCtx.canvas.height = height;
            
            tempCtx.fillStyle = invert ? 'black' : 'white';
            tempCtx.fillRect(0, 0, width, height);
            
            toGrayscale(data);
            
            for (let y = 0; y < height; y += spacing) {
                for (let x = 0; x < width; x += spacing) {
                    const i = (y * width + x) * 4;
                    const brightness = data[i];
                    
                    let radius = (brightness / 255) * (spacing / 2);
                    if (invert) {
                        radius = (255 - brightness) / 255 * (spacing / 2);
                    }

                    if (radius > 0) {
                        tempCtx.beginPath();
                        tempCtx.arc(x, y, radius, 0, 2 * Math.PI);
                        tempCtx.fillStyle = invert ? 'white' : 'black';
                        tempCtx.fill();
                    }
                }
            }
            
            const tempImageData = tempCtx.getImageData(0, 0, width, height);
            for (let i = 0; i < data.length; i += 4) {
                data[i] = tempImageData.data[i];
                data[i + 1] = tempImageData.data[i + 1];
                data[i + 2] = tempImageData.data[i + 2];
            }
        }
        
        function applyWatercolor(imageData, params) {
            const { data, width, height } = imageData;
            const { softness, intensity } = params;

            applyBlur(data, width, height, softness);
            applySaturation(data, 100 * intensity);
            applyContrast(data, 100 + (intensity - 1) * 50);
        }

        function applyOilPainting(imageData, params) {
            const { data, width, height } = imageData;
            const { brushSize, clarity } = params;
            const temp = new Uint8ClampedArray(data);

            for (let y = 0; y < height; y += brushSize) {
                for (let x = 0; x < width; x += brushSize) {
                    let r_avg = 0, g_avg = 0, b_avg = 0, count = 0;
                    for (let dy = 0; dy < brushSize && (y + dy) < height; dy++) {
                        for (let dx = 0; dx < brushSize && (x + dx) < width; dx++) {
                            const index = ((y + dy) * width + (x + dx)) * 4;
                            r_avg += temp[index];
                            g_avg += temp[index + 1];
                            b_avg += temp[index + 2];
                            count++;
                        }
                    }
                    r_avg /= count; g_avg /= count; b_avg /= count;

                    for (let dy = 0; dy < brushSize && (y + dy) < height; dy++) {
                        for (let dx = 0; dx < brushSize && (x + dx) < width; dx++) {
                            const index = ((y + dy) * width + (x + dx)) * 4;
                            data[index] = r_avg;
                            data[index + 1] = g_avg;
                            data[index + 2] = b_avg;
                        }
                    }
                }
            }
            applyContrast(data, 100 * clarity);
        }

        function applyPixelArt(imageData, params) {
            const { data, width, height } = imageData;
            const { pixelSize, edgeColor } = params;
            const originalDataCopy = new Uint8ClampedArray(data);

            for (let y = 0; y < height; y += pixelSize) {
                for (let x = 0; x < width; x += pixelSize) {
                    let r_avg = 0, g_avg = 0, b_avg = 0, count = 0;
                    for (let dy = 0; dy < pixelSize && (y + dy) < height; dy++) {
                        for (let dx = 0; dx < pixelSize && (x + dx) < width; dx++) {
                            const index = ((y + dy) * width + (x + dx)) * 4;
                            r_avg += originalDataCopy[index];
                            g_avg += originalDataCopy[index + 1];
                            b_avg += originalDataCopy[index + 2];
                            count++;
                        }
                    }
                    r_avg = Math.round(r_avg / count);
                    g_avg = Math.round(g_avg / count);
                    b_avg = Math.round(b_avg / count);

                    for (let dy = 0; dy < pixelSize && (y + dy) < height; dy++) {
                        for (let dx = 0; dx < pixelSize && (x + dx) < width; dx++) {
                            const index = ((y + dy) * width + (x + dx)) * 4;
                            if (edgeColor && (dx === 0 || dy === 0)) {
                                data[index] = 0;
                                data[index + 1] = 0;
                                data[index + 2] = 0;
                            } else {
                                data[index] = r_avg;
                                data[index + 1] = g_avg;
                                data[index + 2] = b_avg;
                            }
                        }
                    }
                }
            }
        }

        function applyVintagePhoto(imageData, params) {
            const { data } = imageData;
            const { saturation, contrast } = params;

            applySaturation(data, saturation);
            applyContrast(data, contrast);

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i], g = data[i + 1], b = data[i + 2];
                const newR = Math.min(255, r * 0.9 + g * 0.2 + b * 0.1);
                const newG = Math.min(255, r * 0.1 + g * 0.8 + b * 0.1);
                const newB = Math.min(255, r * 0.1 + g * 0.1 + b * 0.7);
                data[i] = newR; data[i + 1] = newG; data[i + 2] = newB;
            }
        }

        function applyThreshold(imageData, params) {
            const { data } = imageData;
            const { value, invert } = params;
            toGrayscale(data);
            for (let i = 0; i < data.length; i += 4) {
                let pixelValue = data[i];
                if (invert) {
                    data[i] = data[i+1] = data[i+2] = pixelValue > value ? 0 : 255;
                } else {
                    data[i] = data[i+1] = data[i+2] = pixelValue > value ? 255 : 0;
                }
            }
        }

        function applyEmboss(imageData, params) {
            const { data, width, height } = imageData;
            const { intensity, angle } = params;

            const embossKernel = [
                [-2, -1, 0],
                [-1,  1, 1],
                [0,  1, 2]
            ];
            
            const kernelSum = embossKernel.flat().reduce((acc, val) => acc + val, 0);
            const factor = intensity / (kernelSum === 0 ? 1 : kernelSum);
            const offset = 128;
            
            const originalPixels = new Uint8ClampedArray(data);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let r_sum = 0, g_sum = 0, b_sum = 0;
                    for (let ky = 0; ky < 3; ky++) {
                        for (let kx = 0; kx < 3; kx++) {
                            const px = x + kx - 1;
                            const py = y + ky - 1;

                            if (px >= 0 && px < width && py >= 0 && py < height) {
                                const originalIndex = (py * width + px) * 4;
                                const weight = embossKernel[ky][kx];
                                r_sum += originalPixels[originalIndex] * weight;
                                g_sum += originalPixels[originalIndex + 1] * weight;
                                b_sum += originalPixels[originalIndex + 2] * weight;
                            }
                        }
                    }
                    const currentIndex = (y * width + x) * 4;
                    data[currentIndex] = Math.max(0, Math.min(255, r_sum * factor + offset));
                    data[currentIndex + 1] = Math.max(0, Math.min(255, g_sum * factor + offset));
                    data[currentIndex + 2] = Math.max(0, Math.min(255, b_sum * factor + offset));
                }
            }
            toGrayscale(data);
        }

        function applySepia(imageData, params) {
            const { data } = imageData;
            const { opacity } = params;
            const originalDataCopy = new Uint8ClampedArray(data);

            for (let i = 0; i < data.length; i += 4) {
                const r = originalDataCopy[i], g = originalDataCopy[i + 1], b = originalDataCopy[i + 2];
                const sepiaR = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189));
                const sepiaG = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168));
                const sepiaB = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131));
                
                const factor = opacity / 100;
                data[i] = r * (1 - factor) + sepiaR * factor;
                data[i + 1] = g * (1 - factor) + sepiaG * factor;
                data[i + 2] = b * (1 - factor) + sepiaB * factor;
            }
        }

        function applyNegative(imageData, params) {
            const { data } = imageData;
            const { brightness } = params;
            for (let i = 0; i < data.length; i += 4) {
                data[i] = 255 - data[i];
                data[i + 1] = 255 - data[i + 1];
                data[i + 2] = 255 - data[i + 2];
            }
            applyBrightness(data, brightness);
        }

        function applyGlitchEffect(imageData, params) {
            const { data, width, height } = imageData;
            const { intensity, shift, channels } = params;
            
            const originalData = new Uint8ClampedArray(data);
            
            for (let i = 0; i < intensity; i++) {
                const bandHeight = Math.max(1, Math.floor(height / intensity));
                const bandStart = Math.floor(Math.random() * height);
                
                for (let y = bandStart; y < Math.min(height, bandStart + bandHeight); y++) {
                    const shiftX = Math.floor(Math.random() * shift) * (Math.random() > 0.5 ? 1 : -1);
                    
                    for (let x = 0; x < width; x++) {
                        const origX = Math.max(0, Math.min(width - 1, x + shiftX));
                        const origIndex = (y * width + origX) * 4;
                        const newIndex = (y * width + x) * 4;
                        
                        if (channels) {
                            if (Math.random() > 0.7) data[newIndex] = originalData[origIndex];
                            if (Math.random() > 0.7) data[newIndex + 1] = originalData[origIndex + 1];
                            if (Math.random() > 0.7) data[newIndex + 2] = originalData[origIndex + 2];
                        } else {
                            data[newIndex] = originalData[origIndex];
                            data[newIndex + 1] = originalData[origIndex + 1];
                            data[newIndex + 2] = originalData[origIndex + 2];
                        }
                    }
                }
            }
            
            for (let i = 0; i < intensity * 2; i++) {
                const y = Math.floor(Math.random() * height);
                const lineHeight = Math.max(1, Math.floor(Math.random() * 3));
                
                for (let y2 = y; y2 < Math.min(height, y + lineHeight); y2++) {
                    for (let x = 0; x < width; x++) {
                        const index = (y2 * width + x) * 4;
                        if (Math.random() > 0.8) {
                            data[index] = 255;
                            data[index + 1] = 255;
                            data[index + 2] = 255;
                        } else if (Math.random() > 0.9) {
                            data[index] = 0;
                            data[index + 1] = 0;
                            data[index + 2] = 0;
                        }
                    }
                }
            }
        }

        function applyVaporwaveEffect(imageData, params) {
            const { data } = imageData;
            const { intensity, pastel, brightness } = params;
            
            applyBrightness(data, brightness);
            
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i], g = data[i + 1], b = data[i + 2];
                
                if (pastel) {
                    data[i] = Math.min(255, (r + 255) / 2);
                    data[i + 1] = Math.min(255, (g + 200) / 2);
                    data[i + 2] = Math.min(255, (b + 255) / 2);
                } else {
                    data[i] = Math.min(255, r * 1.2);
                    data[i + 1] = g * 0.8;
                    data[i + 2] = Math.min(255, b * 1.1);
                }
                
                const tintFactor = intensity / 100;
                data[i] = Math.min(255, data[i] * (1 - tintFactor) + 255 * tintFactor * 0.5);
                data[i + 1] = Math.min(255, data[i + 1] * (1 - tintFactor) + 180 * tintFactor * 0.5);
                data[i + 2] = Math.min(255, data[i + 2] * (1 - tintFactor) + 255 * tintFactor);
            }
            
            applySaturation(data, 130);
        }

        // Inicializar favoritos al cargar
        updateFavoritesDisplay();
    </script>
</body>
</html>