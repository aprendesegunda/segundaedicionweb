<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>✨ Mega Conversor Musical Pro ✨</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2ecc71;
            --accent-color: #e74c3c;
            --dark-color: #2c3e50;
            --light-color: #ecf0f1;
            --purple-color: #9b59b6;
            --orange-color: #e67e22;
            --yellow-color: #f1c40f;
        }
        
        /* Animaciones personalizadas */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        @keyframes rainbow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            color: var(--dark-color);
            overflow-x: hidden;
                border-radius: 10px;
  max-width: 1200px;
  margin: 90px auto;
        }
        
        /* Header animado */
        .header {
            text-align: center;
            margin-bottom: 30px;
            animation: float 6s ease-in-out infinite;
        }
        
        h1 {
            color: var(--dark-color);
            margin-bottom: 10px;
            font-size: 3rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
            background: linear-gradient(to right, var(--primary-color), var(--secondary-color), var(--accent-color), var(--purple-color));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            background-size: 300% 300%;
            animation: rainbow 8s ease infinite;
        }
        
        .subtitle {
            color: #7f8c8d;
            font-size: 1.2rem;
            max-width: 700px;
            line-height: 1.5;
        }
        
        /* Contenedor principal con efecto 3D */
        .container {
            background-color: white;
            border-radius: 20px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.2);
            padding: 30px;
            width: 95%;
            max-width: 1000px;
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            transform-style: preserve-3d;
            perspective: 1000px;
            border: 1px solid rgba(255,255,255,0.3);
        }
        
        .container:hover {
            transform: translateY(-10px) rotateX(1deg) rotateY(1deg);
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.3);
        }
        
        .container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 8px;
            background: linear-gradient(to right, var(--primary-color), var(--secondary-color), var(--accent-color), var(--purple-color), var(--orange-color));
            background-size: 400% 400%;
            animation: rainbow 8s ease infinite;
        }
        
        /* Área de texto con efecto de neón al enfocar */
        .input-container {
            position: relative;
            margin-bottom: 30px;
        }
        
        textarea {
            width: 100%;
            height: 200px;
            padding: 20px;
            border: 2px solid #ddd;
            border-radius: 15px;
            resize: vertical;
            font-size: 16px;
            transition: all 0.3s;
            font-family: 'Courier New', monospace;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.05);
            background-color: rgba(255,255,255,0.8);
        }
        
        textarea:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 20px rgba(52, 152, 219, 0.5), inset 0 0 10px rgba(0,0,0,0.05);
            outline: none;
            animation: pulse 2s infinite;
        }
        
        .char-counter {
            position: absolute;
            bottom: 10px;
            right: 15px;
            font-size: 0.8rem;
            color: #7f8c8d;
            background-color: rgba(255,255,255,0.7);
            padding: 2px 8px;
            border-radius: 10px;
        }
        
        /* Controles con estilo futurista */
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }
        
        .control-group {
            position: relative;
            background-color: rgba(255,255,255,0.7);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
            transition: all 0.3s;
            border: 1px solid rgba(0,0,0,0.05);
        }
        
        .control-group:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            background-color: white;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 12px;
            font-weight: 600;
            color: var(--dark-color);
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .control-group label i {
            color: var(--primary-color);
            font-size: 1.1rem;
        }
        
        .control-group select, .control-group input[type="range"] {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #eee;
            border-radius: 10px;
            font-size: 14px;
            transition: all 0.3s;
            background-color: white;
            appearance: none;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .control-group select:focus, .control-group input[type="range"]:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
            outline: none;
        }
        
        .control-group select {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23333' stroke-width='3' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 15px center;
            background-size: 15px;
        }
        
        /* Slider personalizado */
        .range-container {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 10px;
        }
        
        .range-value {
            min-width: 60px;
            text-align: center;
            background-color: var(--light-color);
            padding: 8px 12px;
            border-radius: 8px;
            font-weight: bold;
            font-size: 0.9rem;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
            transition: all 0.3s;
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            height: 10px;
            background: linear-gradient(to right, #eee, #ddd);
            border-radius: 5px;
            flex-grow: 1;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            background: var(--primary-color);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            border: 3px solid white;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            background: var(--secondary-color);
            box-shadow: 0 3px 8px rgba(0,0,0,0.3);
        }
        
        /* Botones con iconos y efectos */
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 30px;
            justify-content: center;
        }
        
        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
            min-width: 180px;
            position: relative;
            overflow: hidden;
        }
        
        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: all 0.5s;
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.2);
        }
        
        button:hover::before {
            left: 100%;
        }
        
        button:active {
            transform: translateY(1px);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        
        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            opacity: 0.7;
        }
        
        button:disabled:hover::before {
            left: -100%;
        }
        
        #convertBtn {
            background-color: var(--secondary-color);
        }
        
        #convertBtn:hover {
            background-color: #27ae60;
        }
        
        #playBtn {
            background-color: var(--primary-color);
        }
        
        #stopBtn {
            background-color: var(--accent-color);
        }
        
        #stopBtn:hover {
            background-color: #c0392b;
        }
        
        #saveBtn {
            background-color: var(--purple-color);
        }
        
        #saveBtn:hover {
            background-color: #8e44ad;
        }
        
        #shareBtn {
            background-color: var(--orange-color);
        }
        
        #shareBtn:hover {
            background-color: #d35400;
        }
        
        #theoryBtn {
            background-color: var(--yellow-color);
            color: var(--dark-color);
        }
        
        #theoryBtn:hover {
            background-color: #f39c12;
        }
        
        /* Visualizador de audio mejorado */
        .visualizer-container {
            margin-top: 30px;
            width: 100%;
            height: 250px;
            background: linear-gradient(to bottom, #f9f9f9, #e9e9e9);
            border-radius: 15px;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 0 15px rgba(0,0,0,0.1);
            border: 1px solid rgba(0,0,0,0.05);
        }
        
        .visualizer {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        .note-bar {
            position: absolute;
            bottom: 0;
            width: 12px;
            background: linear-gradient(to top, var(--primary-color), var(--secondary-color));
            border-radius: 6px 6px 0 0;
            transition: height 0.3s, opacity 0.3s, transform 0.3s;
            opacity: 0.8;
            box-shadow: 0 -3px 8px rgba(0,0,0,0.2);
            transform-origin: bottom;
        }
        
        .waveform {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 50%;
            opacity: 0.1;
            background: repeating-linear-gradient(
                to right,
                var(--primary-color),
                var(--primary-color) 1px,
                transparent 1px,
                transparent 3px
            );
        }
        
        /* Información de reproducción con efecto de máquina de escribir */
        .playback-info {
            margin-top: 25px;
            padding: 20px;
            background-color: var(--light-color);
            border-radius: 15px;
            width: 100%;
            font-size: 1rem;
            position: relative;
            overflow: hidden;
            box-shadow: 0 3px 10px rgba(0,0,0,0.05);
            min-height: 80px;
            border: 1px solid rgba(0,0,0,0.05);
        }
        
        .playback-info::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 0;
            background: linear-gradient(to right, rgba(52, 152, 219, 0.1), transparent);
            transition: width 0.5s;
        }
        
        .playback-info.active::before {
            width: 100%;
        }
        
        #currentAction {
            font-size: 1.1rem;
            margin-bottom: 10px;
            font-weight: 600;
        }
        
        #currentNote {
            font-size: 0.9rem;
            color: #7f8c8d;
            font-family: 'Courier New', monospace;
        }
        
        /* Estadísticas con iconos */
        .stats-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 20px;
            margin-top: 30px;
            width: 100%;
        }
        
        .stat-box {
            background-color: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
            text-align: center;
            transition: all 0.3s;
            border: 1px solid rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .stat-box:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }
        
        .stat-icon {
            font-size: 2rem;
            margin-bottom: 10px;
            color: var(--primary-color);
        }
        
        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: var(--dark-color);
            margin-bottom: 5px;
            background: linear-gradient(to right, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        .stat-label {
            font-size: 0.9rem;
            color: #7f8c8d;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
        }
        
        /* Efectos de celebración mejorados */
        .completion-effect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
            display: none;
            overflow: hidden;
        }
        
        .confetti {
            position: absolute;
            width: 15px;
            height: 15px;
            background-color: var(--primary-color);
            border-radius: 50%;
            animation: fall linear forwards;
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
        }
        
        .firework {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            box-shadow: 0 0 15px 8px;
            animation: explode 1s forwards;
            opacity: 0;
        }
        
        .emoji-effect {
            position: absolute;
            font-size: 28px;
            animation: float-up 2s forwards;
            opacity: 0;
            text-shadow: 0 0 10px rgba(0,0,0,0.3);
            z-index: 1001;
        }
        
        .music-note {
            position: absolute;
            font-size: 24px;
            animation: note-float 3s linear forwards;
            opacity: 0;
            z-index: 1001;
        }
        
        /* Animaciones */
        @keyframes fall {
            to {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }
        
        @keyframes explode {
            0% {
                transform: scale(0.1);
                opacity: 0;
            }
            50% {
                opacity: 1;
            }
            100% {
                transform: scale(2);
                opacity: 0;
            }
        }
        
        @keyframes float-up {
            0% {
                transform: translateY(0) scale(0.5);
                opacity: 0;
            }
            20% {
                opacity: 1;
            }
            100% {
                transform: translateY(-150px) scale(1.5);
                opacity: 0;
            }
        }
        
        @keyframes note-float {
            0% {
                transform: translateY(0) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(-150px) rotate(360deg);
                opacity: 0;
            }
        }
        
        /* Teclado virtual interactivo */
        .keyboard-container {
            margin-top: 40px;
            width: 100%;
            overflow-x: auto;
            padding-bottom: 20px;
        }
        
        .keyboard {
            display: flex;
            height: 200px;
            min-width: 600px;
            position: relative;
            margin: 0 auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            border-radius: 10px;
            overflow: hidden;
        }
        
        .white-key {
            flex: 1;
            background-color: white;
            border: 1px solid #ddd;
            height: 100%;
            position: relative;
            z-index: 1;
            transition: all 0.1s;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            padding-bottom: 10px;
            font-weight: bold;
            color: #7f8c8d;
        }
        
        .white-key.active {
            background-color: var(--primary-color);
            color: white;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.2);
        }
        
        .black-key {
            width: 60%;
            height: 60%;
            background-color: #333;
            position: absolute;
            z-index: 2;
            margin-left: -30%;
            border-radius: 0 0 5px 5px;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            padding-bottom: 10px;
            color: white;
            font-weight: bold;
            transition: all 0.1s;
        }
        
        .black-key.active {
            background-color: var(--purple-color);
            box-shadow: inset 0 0 20px rgba(0,0,0,0.3);
        }
        
        /* Notificación */
        .notification {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background-color: var(--secondary-color);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            transform: translateX(200%);
            transition: transform 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            z-index: 10000;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .notification.show {
            transform: translateX(0);
        }
        
        /* Modal de teoría musical */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            z-index: 10000;
            overflow-y: auto;
        }
        
        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 30px;
            border-radius: 15px;
            width: 80%;
            max-width: 800px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            position: relative;
            animation: modalFadeIn 0.3s;
        }
        
        @keyframes modalFadeIn {
            from { opacity: 0; transform: translateY(-50px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .close-modal {
            position: absolute;
            top: 15px;
            right: 15px;
            font-size: 1.5rem;
            cursor: pointer;
            color: #7f8c8d;
            transition: all 0.3s;
        }
        
        .close-modal:hover {
            color: var(--accent-color);
            transform: rotate(90deg);
        }
        
        .modal-title {
            font-size: 1.8rem;
            margin-bottom: 20px;
            color: var(--primary-color);
            border-bottom: 2px solid var(--light-color);
            padding-bottom: 10px;
        }
        
        .theory-section {
            margin-bottom: 25px;
        }
        
        .theory-section h3 {
            color: var(--dark-color);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .theory-section h3 i {
            color: var(--secondary-color);
        }
        
        .theory-section p {
            line-height: 1.6;
            margin-bottom: 15px;
        }
        
        .scale-diagram {
            background-color: var(--light-color);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
        
        .note-highlight {
            background-color: var(--yellow-color);
            padding: 2px 5px;
            border-radius: 4px;
            color: var(--dark-color);
            font-weight: bold;
        }
        
        /* Modo oscuro */
        @media (prefers-color-scheme: dark) {
            body {
                background: linear-gradient(135deg, #2c3e50 0%, #1a1a1a 100%);
                color: #ecf0f1;
            }
            
            .container {
                background-color: #34495e;
                color: #ecf0f1;
            }
            
            textarea {
                background-color: #2c3e50;
                color: #ecf0f1;
                border-color: #7f8c8d;
            }
            
            .control-group {
                background-color: rgba(44, 62, 80, 0.7);
            }
            
            .control-group:hover {
                background-color: #2c3e50;
            }
            
            .control-group select, .control-group input[type="range"] {
                background-color: #2c3e50;
                color: #ecf0f1;
                border-color: #7f8c8d;
            }
            
            .playback-info {
                background-color: #2c3e50;
                color: #ecf0f1;
            }
            
            .visualizer-container {
                background: linear-gradient(to bottom, #2c3e50, #1a1a1a);
            }
            
            .stat-box {
                background-color: #2c3e50;
                color: #ecf0f1;
            }
            
            .white-key {
                background-color: #34495e;
                border-color: #2c3e50;
                color: #bdc3c7;
            }
            
            .black-key {
                background-color: #1a1a1a;
            }
            
            .modal-content {
                background-color: #2c3e50;
                color: #ecf0f1;
            }
            
            .modal-title {
                color: var(--secondary-color);
            }
            
            .scale-diagram {
                background-color: #34495e;
                color: #ecf0f1;
            }
            
            .note-highlight {
                background-color: var(--orange-color);
                color: white;
            }
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .controls {
                grid-template-columns: 1fr;
            }
            
            .button-group {
                flex-direction: column;
                align-items: center;
            }
            
            button {
                width: 100%;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .subtitle {
                font-size: 1rem;
            }
            
            .modal-content {
                width: 95%;
                padding: 20px;
            }
        }
           .btn-volver {
      display: inline-block;
      padding: 10px 20px;
      background-color: #3498db;
      color: white;
      font-size: 16px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s ease;
      text-align: center;
      text-decoration: none;
      user-select: none;
    }

    .btn-volver:hover {
      background-color: #2980b9;
    }
    </style>
</head>
<body>
    <div class="header">
        <h1>✨ Mega Conversor Musical Pro ✨</h1>
        <p class="subtitle">Transforma cualquier texto en una composición musical profesional con teoría integrada</p>
    </div>
      <!-- Esto es un enlace con apariencia de botón -->
  <a href="disenopresentaciontodo1.html" class="btn-volver">← Volver a Inicio</a>
    <div class="container">
        <div class="input-container">
            <textarea id="textInput" placeholder="Escribe o pega tu texto aquí... Cada carácter se convertirá en una nota musical según principios musicológicos ✨"></textarea>
            <div class="char-counter"><span id="charCount">0</span> caracteres</div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label for="scale"><i class="fas fa-music"></i> Escala Musical</label>
                <select id="scale">
                    <option value="major">Mayor (alegre y brillante)</option>
                    <option value="minor">Menor (melancólica y emotiva)</option>
                    <option value="pentatonic">Pentatónica (armonía oriental)</option>
                    <option value="chromatic">Cromática (experimental)</option>
                    <option value="blues">Blues (soul y feeling)</option>
                    <option value="harmonic">Armónica (misteriosa)</option>
                    <option value="dorian">Dorian (jazz y rock)</option>
                    <option value="phrygian">Frigia (flamenco y metal)</option>
                    <option value="lydian">Lidia (dreamy, suspenso)</option>
                    <option value="mixolydian">Mixolidia (rock, folk)</option>
                    <option value="locrian">Locria (disonante, tensión)</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="tempo"><i class="fas fa-tachometer-alt"></i> Velocidad (BPM)</label>
                <div class="range-container">
                    <input type="range" id="tempo" min="40" max="300" value="120">
                    <span id="tempoValue" class="range-value">120</span>
                </div>
            </div>
            
            <div class="control-group">
                <label for="instrument"><i class="fas fa-guitar"></i> Instrumento</label>
                <select id="instrument">
                    <option value="sine">Sinusoidal (tono puro)</option>
                    <option value="square">Cuadrada (8-bit retro)</option>
                    <option value="sawtooth">Sierra (áspero y potente)</option>
                    <option value="triangle">Triangular (suave y dulce)</option>
                    <option value="piano">Piano acústico</option>
                    <option value="guitar">Guitarra eléctrica</option>
                    <option value="strings">Cuerdas orquestales</option>
                    <option value="synth">Sintetizador futurista</option>
                    <option value="flute">Flauta (melodías suaves)</option>
                    <option value="trumpet">Trompeta (brillante)</option>
                    <option value="bass">Bajo (profundo)</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="effects"><i class="fas fa-sliders-h"></i> Efectos de Audio</label>
                <select id="effects" multiple>
                    <option value="reverb">Reverb (espacio acústico)</option>
                    <option value="delay">Delay (eco)</option>
                    <option value="chorus">Chorus (coro)</option>
                    <option value="distortion" selected>Distorsión (rock)</option>
                    <option value="filter">Filtro (wah-wah)</option>
                    <option value="compressor">Compresor (balance)</option>
                    <option value="phaser">Phaser (efecto espacial)</option>
                    <option value="flanger">Flanger (efecto volador)</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="style"><i class="fas fa-paint-brush"></i> Estilo Musical</label>
                <select id="style">
                    <option value="normal">Normal</option>
                    <option value="arpeggio">Arpegio</option>
                    <option value="staccato">Staccato (picado)</option>
                    <option value="legato">Legato (ligado)</option>
                    <option value="random">Aleatorio</option>
                    <option value="swing">Swing (jazz feel)</option>
                    <option value="reverse">Invertido (efecto especial)</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="visualization"><i class="fas fa-eye"></i> Visualización</label>
                <select id="visualization">
                    <option value="bars">Barras de notas</option>
                    <option value="wave">Ondas</option>
                    <option value="particles">Partículas</option>
                    <option value="spectrum">Espectro</option>
                    <option value="circular">Circular</option>
                    <option value="piano">Rollo de piano</option>
                </select>
            </div>
        </div>
        
        <div class="button-group">
            <button id="convertBtn">
                <i class="fas fa-exchange-alt"></i>
                Convertir
            </button>
            <button id="playBtn" disabled>
                <i class="fas fa-play"></i>
                Reproducir
            </button>
            <button id="stopBtn" disabled>
                <i class="fas fa-stop"></i>
                Detener
            </button>
            <button id="saveBtn" disabled>
                <i class="fas fa-save"></i>
                Guardar MIDI
            </button>
            <button id="shareBtn">
                <i class="fas fa-share-alt"></i>
                Compartir
            </button>
            <button id="theoryBtn">
                <i class="fas fa-book"></i>
                Teoría Musical
            </button>
        </div>
        
        <div class="visualizer-container">
            <div class="visualizer" id="visualizer">
                <div class="waveform"></div>
            </div>
        </div>
        
        <div class="playback-info" id="playbackInfo">
            <div id="currentAction">Esperando entrada de texto...</div>
            <div id="currentNote"></div>
        </div>
        
        <div class="stats-container">
            <div class="stat-box">
                <div class="stat-icon"><i class="fas fa-font"></i></div>
                <div class="stat-value" id="charCount">0</div>
                <div class="stat-label">Caracteres</div>
            </div>
            <div class="stat-box">
                <div class="stat-icon"><i class="fas fa-music"></i></div>
                <div class="stat-value" id="noteCount">0</div>
                <div class="stat-label">Notas</div>
            </div>
            <div class="stat-box">
                <div class="stat-icon"><i class="fas fa-clock"></i></div>
                <div class="stat-value" id="duration">0s</div>
                <div class="stat-label">Duración</div>
            </div>
            <div class="stat-box">
                <div class="stat-icon"><i class="fas fa-brain"></i></div>
                <div class="stat-value" id="complexity">-</div>
                <div class="stat-label">Complejidad</div>
            </div>
        </div>
        
        <div class="keyboard-container">
            <div class="keyboard" id="keyboard">
                <!-- Teclado se generará con JavaScript -->
            </div>
        </div>
    </div>
    
    <div class="completion-effect" id="completionEffect"></div>
    
    <div class="notification" id="notification">
        <i class="fas fa-check-circle"></i>
        <span id="notificationText">¡Conversión completada con éxito!</span>
    </div>
    
    <!-- Modal de teoría musical -->
    <div class="modal" id="theoryModal">
        <div class="modal-content">
            <span class="close-modal">&times;</span>
            <h2 class="modal-title"><i class="fas fa-book-open"></i> Teoría Musical Aplicada</h2>
            
            <div class="theory-section">
                <h3><i class="fas fa-music"></i> Escalas Musicales</h3>
                <p>Las escalas son conjuntos de notas ordenadas que forman la base de la melodía y armonía en la música. Cada escala tiene un carácter emocional único:</p>
                
                <div class="scale-diagram">
                    <p><strong>Escala Mayor (C D E F G A B):</strong> <span class="note-highlight">Tono - Tono - Semitono - Tono - Tono - Tono - Semitono</span></p>
                    <p>Sonido alegre y brillante. Usada en pop, música clásica y más.</p>
                </div>
                
                <div class="scale-diagram">
                    <p><strong>Escala Menor Natural (A B C D E F G):</strong> <span class="note-highlight">Tono - Semitono - Tono - Tono - Semitono - Tono - Tono</span></p>
                    <p>Sonido melancólico y emotivo. Común en blues, baladas y música clásica.</p>
                </div>
                
                <div class="scale-diagram">
                    <p><strong>Escala Pentatónica (C D E G A):</strong> <span class="note-highlight">Tono - Tono - Tono y 1/2 - Tono - Tono y 1/2</span></p>
                    <p>Versátil y sin notas disonantes. Usada en música oriental, rock y blues.</p>
                </div>
            </div>
            
            <div class="theory-section">
                <h3><i class="fas fa-sliders-h"></i> Efectos de Audio</h3>
                <p>Los efectos modifican el sonido para crear atmósferas y texturas únicas:</p>
                
                <p><strong>Reverb:</strong> Simula el sonido en diferentes espacios acústicos (salas, catedrales, etc.).</p>
                <p><strong>Delay:</strong> Crea ecos que se repiten con retraso, añadiendo profundidad.</p>
                <p><strong>Distorsión:</strong> Añade saturación y calidez, esencial para guitarras de rock.</p>
                <p><strong>Chorus:</strong> Duplica la señal con ligeras variaciones para un sonido más "grueso".</p>
            </div>
            
            <div class="theory-section">
                <h3><i class="fas fa-guitar"></i> Instrumentos Virtuales</h3>
                <p>Cada instrumento tiene un timbre característico definido por su forma de onda:</p>
                
                <p><strong>Sinusoidal:</strong> Onda pura sin armónicos, sonido suave y redondo.</p>
                <p><strong>Cuadrada:</strong> Sonido rico en armónicos impares, característico de chips 8-bit.</p>
                <p><strong>Sierra:</strong> Contiene todos los armónicos, sonido brillante y agresivo.</p>
                <p><strong>Triangular:</strong> Similar a la sinusoidal pero con armónicos impares atenuados.</p>
            </div>
            
            <div class="theory-section">
                <h3><i class="fas fa-lightbulb"></i> Consejos de Composición</h3>
                <p>Para crear melodías más interesantes:</p>
                
                <p>- Usa textos con variedad de caracteres para mayor diversidad de notas.</p>
                <p>- Experimenta con diferentes escalas para cambiar el carácter emocional.</p>
                <p>- Combina efectos para crear texturas únicas (reverb + delay = espacio profundo).</p>
                <p>- Ajusta el tempo según el estilo deseado (lento para baladas, rápido para energía).</p>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Elementos del DOM
            const elements = {
                textInput: document.getElementById('textInput'),
                scaleSelect: document.getElementById('scale'),
                tempoSlider: document.getElementById('tempo'),
                tempoValue: document.getElementById('tempoValue'),
                instrumentSelect: document.getElementById('instrument'),
                effectsSelect: document.getElementById('effects'),
                styleSelect: document.getElementById('style'),
                visualizationSelect: document.getElementById('visualization'),
                convertBtn: document.getElementById('convertBtn'),
                playBtn: document.getElementById('playBtn'),
                stopBtn: document.getElementById('stopBtn'),
                saveBtn: document.getElementById('saveBtn'),
                shareBtn: document.getElementById('shareBtn'),
                theoryBtn: document.getElementById('theoryBtn'),
                playbackInfo: document.getElementById('playbackInfo'),
                currentAction: document.getElementById('currentAction'),
                currentNote: document.getElementById('currentNote'),
                visualizer: document.getElementById('visualizer'),
                completionEffect: document.getElementById('completionEffect'),
                charCount: document.getElementById('charCount'),
                noteCount: document.getElementById('noteCount'),
                duration: document.getElementById('duration'),
                complexity: document.getElementById('complexity'),
                keyboard: document.getElementById('keyboard'),
                notification: document.getElementById('notification'),
                notificationText: document.getElementById('notificationText'),
                theoryModal: document.getElementById('theoryModal'),
                closeModal: document.querySelector('.close-modal')
            };
            
            // Configuración de audio
            let audioContext;
            let currentNotes = [];
            let isPlaying = false;
            let playbackTimeout;
            let activeOscillators = [];
            let audioNodes = {
                mainGain: null,
                analyser: null,
                effects: {}
            };
            
            // Inicializar el contexto de audio
            function initAudio() {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Configurar nodos de audio
                    audioNodes.mainGain = audioContext.createGain();
                    audioNodes.mainGain.gain.value = 0.5;
                    audioNodes.mainGain.connect(audioContext.destination);
                    
                    // Configurar analizador para visualización
                    audioNodes.analyser = audioContext.createAnalyser();
                    audioNodes.analyser.fftSize = 512;
                    audioNodes.analyser.connect(audioNodes.mainGain);
                    
                    // Configurar efectos
                    setupEffects();
                    
                    // Iniciar visualización
                    visualizeAudio();
                }
            }
            
            // Configurar efectos de audio
            function setupEffects() {
                // Distorsión
                audioNodes.effects.distortion = audioContext.createWaveShaper();
                audioNodes.effects.distortion.curve = makeDistortionCurve(400);
                audioNodes.effects.distortion.oversample = '4x';
                
                // Reverb (convolver)
                audioNodes.effects.reverb = audioContext.createConvolver();
                // Simular reverb con un impulso simple
                const reverbLength = audioContext.sampleRate * 1.5;
                const impulseBuffer = audioContext.createBuffer(2, reverbLength, audioContext.sampleRate);
                const leftChannel = impulseBuffer.getChannelData(0);
                const rightChannel = impulseBuffer.getChannelData(1);
                
                for (let i = 0; i < reverbLength; i++) {
                    const n = reverbLength - i;
                    leftChannel[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / reverbLength, 3);
                    rightChannel[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / reverbLength, 3);
                }
                
                audioNodes.effects.reverb.buffer = impulseBuffer;
                
                // Delay
                audioNodes.effects.delay = audioContext.createDelay(2.0);
                audioNodes.effects.delay.delayTime.value = 0.5;
                const delayGain = audioContext.createGain();
                delayGain.gain.value = 0.4;
                audioNodes.effects.delay.connect(delayGain);
                delayGain.connect(audioNodes.mainGain);
                
                // Chorus
                audioNodes.effects.chorus = {
                    depth: audioContext.createGain(),
                    delay: audioContext.createDelay(0.02),
                    lfo: audioContext.createOscillator(),
                    gain: audioContext.createGain()
                };
                
                audioNodes.effects.chorus.delay.delayTime.value = 0.01;
                audioNodes.effects.chorus.lfo.frequency.value = 2;
                audioNodes.effects.chorus.depth.gain.value = 0.005;
                audioNodes.effects.chorus.gain.gain.value = 0.5;
                
                audioNodes.effects.chorus.lfo.connect(audioNodes.effects.chorus.depth);
                audioNodes.effects.chorus.depth.connect(audioNodes.effects.chorus.delay.delayTime);
                audioNodes.effects.chorus.delay.connect(audioNodes.effects.chorus.gain);
                audioNodes.effects.chorus.gain.connect(audioNodes.mainGain);
                audioNodes.effects.chorus.lfo.start();
                
                // Filtro
                audioNodes.effects.filter = audioContext.createBiquadFilter();
                audioNodes.effects.filter.type = 'lowpass';
                audioNodes.effects.filter.frequency.value = 2000;
                audioNodes.effects.filter.Q.value = 1;
                
                // Compresor
                audioNodes.effects.compressor = audioContext.createDynamicsCompressor();
                audioNodes.effects.compressor.threshold.value = -24;
                audioNodes.effects.compressor.knee.value = 30;
                audioNodes.effects.compressor.ratio.value = 12;
                audioNodes.effects.compressor.reduction.value = -20;
                audioNodes.effects.compressor.attack.value = 0.003;
                audioNodes.effects.compressor.release.value = 0.25;
                audioNodes.effects.compressor.connect(audioNodes.mainGain);
                
                // Phaser
                audioNodes.effects.phaser = {
                    input: audioContext.createGain(),
                    output: audioContext.createGain(),
                    filters: [],
                    lfo: audioContext.createOscillator()
                };
                
                for (let i = 0; i < 4; i++) {
                    const filter = audioContext.createBiquadFilter();
                    filter.type = 'allpass';
                    filter.frequency.value = 350;
                    filter.Q.value = 1;
                    audioNodes.effects.phaser.filters.push(filter);
                }
                
                audioNodes.effects.phaser.lfo.frequency.value = 0.5;
                const lfoDepth = audioContext.createGain();
                lfoDepth.gain.value = 1000;
                audioNodes.effects.phaser.lfo.connect(lfoDepth);
                
                // Conectar los filtros en serie
                audioNodes.effects.phaser.input.connect(audioNodes.effects.phaser.filters[0]);
                for (let i = 0; i < 3; i++) {
                    audioNodes.effects.phaser.filters[i].connect(audioNodes.effects.phaser.filters[i + 1]);
                }
                audioNodes.effects.phaser.filters[3].connect(audioNodes.effects.phaser.output);
                
                // Modulación del phaser
                audioNodes.effects.phaser.filters.forEach(filter => {
                    lfoDepth.connect(filter.frequency);
                });
                
                audioNodes.effects.phaser.lfo.start();
                
                // Flanger
                audioNodes.effects.flanger = {
                    input: audioContext.createGain(),
                    output: audioContext.createGain(),
                    delay: audioContext.createDelay(0.02),
                    feedback: audioContext.createGain(),
                    lfo: audioContext.createOscillator(),
                    depth: audioContext.createGain(),
                    wet: audioContext.createGain(),
                    dry: audioContext.createGain()
                };
                
                audioNodes.effects.flanger.delay.delayTime.value = 0.005;
                audioNodes.effects.flanger.feedback.gain.value = 0.5;
                audioNodes.effects.flanger.lfo.frequency.value = 0.2;
                audioNodes.effects.flanger.depth.gain.value = 0.005;
                audioNodes.effects.flanger.wet.gain.value = 0.5;
                audioNodes.effects.flanger.dry.gain.value = 0.5;
                
                // Conexiones del flanger
                audioNodes.effects.flanger.input.connect(audioNodes.effects.flanger.delay);
                audioNodes.effects.flanger.input.connect(audioNodes.effects.flanger.dry);
                audioNodes.effects.flanger.delay.connect(audioNodes.effects.flanger.feedback);
                audioNodes.effects.flanger.delay.connect(audioNodes.effects.flanger.wet);
                audioNodes.effects.flanger.feedback.connect(audioNodes.effects.flanger.delay);
                audioNodes.effects.flanger.wet.connect(audioNodes.effects.flanger.output);
                audioNodes.effects.flanger.dry.connect(audioNodes.effects.flanger.output);
                
                // Modulación del flanger
                audioNodes.effects.flanger.lfo.connect(audioNodes.effects.flanger.depth);
                audioNodes.effects.flanger.depth.connect(audioNodes.effects.flanger.delay.delayTime);
                
                audioNodes.effects.flanger.lfo.start();
            }
            
            // Función para crear curva de distorsión
            function makeDistortionCurve(amount) {
                const k = typeof amount === 'number' ? amount : 50;
                const n_samples = 44100;
                const curve = new Float32Array(n_samples);
                const deg = Math.PI / 180;
                
                for (let i = 0; i < n_samples; i++) {
                    const x = i * 2 / n_samples - 1;
                    curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
                }
                return curve;
            }
            
            // Visualización de audio
            function visualizeAudio() {
                if (!audioContext || !audioNodes.analyser) return;
                
                const canvas = document.createElement('canvas');
                canvas.width = elements.visualizer.clientWidth;
                canvas.height = elements.visualizer.clientHeight;
                elements.visualizer.appendChild(canvas);
                const ctx = canvas.getContext('2d');
                
                const bufferLength = audioNodes.analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                
                function draw() {
                    requestAnimationFrame(draw);
                    
                    audioNodes.analyser.getByteFrequencyData(dataArray);
                    
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    const barWidth = (canvas.width / bufferLength) * 2.5;
                    let x = 0;
                    
                    for (let i = 0; i < bufferLength; i++) {
                        const barHeight = dataArray[i] / 2;
                        
                        ctx.fillStyle = `hsl(${i * 360 / bufferLength}, 100%, 50%)`;
                        ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                        
                        x += barWidth + 1;
                    }
                }
                
                draw();
            }
            
            // Crear teclado virtual
            function createKeyboard() {
                elements.keyboard.innerHTML = '';
                
                // Notas y sus posiciones
                const notes = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
                const blackNotes = ['C#', 'D#', null, 'F#', 'G#', 'A#'];
                
                // Teclas blancas
                notes.forEach((note, i) => {
                    const key = document.createElement('div');
                    key.className = 'white-key';
                    key.dataset.note = note + '4';
                    key.textContent = note;
                    elements.keyboard.appendChild(key);
                });
                
                // Teclas negras
                blackNotes.forEach((note, i) => {
                    if (note) {
                        const key = document.createElement('div');
                        key.className = 'black-key';
                        key.dataset.note = note + '4';
                        key.textContent = note.replace('#', '♯');
                        elements.keyboard.appendChild(key);
                    }
                });
                
                // Event listeners para las teclas
                document.querySelectorAll('.white-key, .black-key').forEach(key => {
                    key.addEventListener('mousedown', () => {
                        const note = key.dataset.note;
                        playTestNote(note);
                        key.classList.add('active');
                    });
                    
                    key.addEventListener('mouseup', () => {
                        key.classList.remove('active');
                    });
                    
                    key.addEventListener('mouseleave', () => {
                        key.classList.remove('active');
                    });
                });
            }
            
            // Reproducir nota de prueba
            function playTestNote(note) {
                initAudio();
                
                const oscillator = audioContext.createOscillator();
                oscillator.type = 'sine';
                oscillator.frequency.value = noteFrequencies[note];
                
                const gainNode = audioContext.createGain();
                gainNode.gain.value = 0.3;
                
                // Aplicar efectos seleccionados
                const selectedEffects = Array.from(elements.effectsSelect.selectedOptions).map(opt => opt.value);
                let lastNode = gainNode;
                
                if (selectedEffects.includes('reverb')) {
                    lastNode.connect(audioNodes.effects.reverb);
                    lastNode = audioNodes.effects.reverb;
                }
                
                if (selectedEffects.includes('distortion')) {
                    lastNode.connect(audioNodes.effects.distortion);
                    lastNode = audioNodes.effects.distortion;
                }
                
                if (selectedEffects.includes('filter')) {
                    lastNode.connect(audioNodes.effects.filter);
                    lastNode = audioNodes.effects.filter;
                }
                
                if (selectedEffects.includes('phaser')) {
                    audioNodes.effects.phaser.output.connect(audioNodes.mainGain);
                    lastNode.connect(audioNodes.effects.phaser.input);
                    lastNode = audioNodes.effects.phaser.output;
                }
                
                if (selectedEffects.includes('flanger')) {
                    audioNodes.effects.flanger.output.connect(audioNodes.mainGain);
                    lastNode.connect(audioNodes.effects.flanger.input);
                    lastNode = audioNodes.effects.flanger.output;
                }
                
                // Conectar al nodo principal si no hay efectos
                if (lastNode === gainNode) {
                    lastNode.connect(audioNodes.mainGain);
                }
                
                const now = audioContext.currentTime;
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(0.3, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                
                oscillator.start(now);
                oscillator.stop(now + 0.5);
                
                // Resaltar nota en el visualizador
                highlightNote(note);
                
                // Mostrar información de la nota
                showNoteInfo(note);
            }
            
            // Mostrar información teórica de la nota
            function showNoteInfo(note) {
                const noteName = note.slice(0, -1);
                const octave = note.slice(-1);
                
                let scaleInfo = "";
                const currentScale = elements.scaleSelect.value;
                const scaleNotes = noteMappings[currentScale] || noteMappings.major;
                
                if (scaleNotes.includes(note)) {
                    scaleInfo = `Esta nota está en la escala ${currentScale} seleccionada.`;
                } else {
                    scaleInfo = `Esta nota no está en la escala ${currentScale} actual.`;
                }
                
                elements.currentAction.textContent = `Nota de prueba: ${note}`;
                elements.currentNote.innerHTML = `
                    Frecuencia: ${Math.round(noteFrequencies[note])} Hz<br>
                    Octava: ${octave}<br>
                    ${scaleInfo}
                `;
                
                elements.playbackInfo.classList.add('active');
                setTimeout(() => {
                    elements.playbackInfo.classList.remove('active');
                }, 2000);
            }
            
            // Mapeo de caracteres a notas musicales
            const noteMappings = {
                major: ['C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'B4', 'C5'],
                minor: ['A3', 'B3', 'C4', 'D4', 'E4', 'F4', 'G4', 'A4'],
                pentatonic: ['C4', 'D4', 'E4', 'G4', 'A4', 'C5'],
                chromatic: ['C4', 'C#4', 'D4', 'D#4', 'E4', 'F4', 'F#4', 'G4', 'G#4', 'A4', 'A#4', 'B4', 'C5'],
                blues: ['C4', 'D#4', 'F4', 'F#4', 'G4', 'A#4', 'C5'],
                harmonic: ['C4', 'D4', 'D#4', 'F4', 'G4', 'G#4', 'B4', 'C5'],
                dorian: ['D4', 'E4', 'F4', 'G4', 'A4', 'B4', 'C5', 'D5'],
                phrygian: ['E4', 'F4', 'G4', 'A4', 'B4', 'C5', 'D5', 'E5'],
                lydian: ['F4', 'G4', 'A4', 'B4', 'C5', 'D5', 'E5', 'F5'],
                mixolydian: ['G4', 'A4', 'B4', 'C5', 'D5', 'E5', 'F5', 'G5'],
                locrian: ['B4', 'C5', 'D5', 'E5', 'F5', 'G5', 'A5', 'B5']
            };
            
            // Frecuencias de las notas
            const noteFrequencies = {
                'A3': 220.00, 'A#3': 233.08, 'Bb3': 233.08, 'B3': 246.94,
                'C4': 261.63, 'C#4': 277.18, 'Db4': 277.18, 'D4': 293.66, 
                'D#4': 311.13, 'Eb4': 311.13, 'E4': 329.63, 'F4': 349.23, 
                'F#4': 369.99, 'Gb4': 369.99, 'G4': 392.00, 'G#4': 415.30, 
                'Ab4': 415.30, 'A4': 440.00, 'A#4': 466.16, 'Bb4': 466.16, 
                'B4': 493.88, 'C5': 523.25, 'C#5': 554.37, 'D5': 587.33,
                'D#5': 622.25, 'E5': 659.25, 'F5': 698.46, 'F#5': 739.99,
                'G5': 783.99, 'G#5': 830.61, 'A5': 880.00
            };
            
            // Convertir texto a notas musicales
            function textToNotes(text, scale) {
                const notes = [];
                const scaleNotes = noteMappings[scale] || noteMappings.major;
                
                for (let i = 0; i < text.length; i++) {
                    const charCode = text.charCodeAt(i);
                    const noteIndex = charCode % scaleNotes.length;
                    notes.push(scaleNotes[noteIndex]);
                }
                
                return notes;
            }
            
            // Calcular complejidad del texto
            function calculateTextComplexity(text) {
                if (!text || text.length === 0) return 0;
                
                let uniqueChars = new Set();
                let charFrequency = {};
                let totalChars = text.length;
                
                for (let char of text) {
                    uniqueChars.add(char);
                    charFrequency[char] = (charFrequency[char] || 0) + 1;
                }
                
                // Calcular entropía
                let entropy = 0;
                for (let char in charFrequency) {
                    let prob = charFrequency[char] / totalChars;
                    entropy -= prob * Math.log2(prob);
                }
                
                // Normalizar (máxima entropía es log2(uniqueChars.size))
                const maxEntropy = Math.log2(uniqueChars.size);
                const normalizedEntropy = maxEntropy > 0 ? entropy / maxEntropy : 0;
                
                // Combinar métricas
                const complexity = (uniqueChars.size / 26) * 0.4 + normalizedEntropy * 0.6;
                
                return Math.min(1, Math.max(0, complexity));
            }
            
            // Mostrar notificación
            function showNotification(message, duration = 3000) {
                elements.notificationText.textContent = message;
                elements.notification.classList.add('show');
                
                setTimeout(() => {
                    elements.notification.classList.remove('show');
                }, duration);
            }
            
            // Reproducir una nota
            function playNote(note, duration, instrument, index, totalNotes) {
                return new Promise((resolve) => {
                    initAudio();
                    
                    let oscillator;
                    let gainNode;
                    
                    // Configurar efectos seleccionados
                    const selectedEffects = Array.from(elements.effectsSelect.selectedOptions).map(opt => opt.value);
                    const style = elements.styleSelect.value;
                    
                    // Crear cadena de nodos de audio
                    let lastNode = audioNodes.mainGain;
                    
                    // Aplicar efectos en orden
                    if (selectedEffects.includes('compressor')) {
                        lastNode = audioNodes.effects.compressor;
                    }
                    
                    if (selectedEffects.includes('distortion')) {
                        audioNodes.effects.distortion.connect(lastNode);
                        lastNode = audioNodes.effects.distortion;
                    }
                    
                    if (selectedEffects.includes('reverb')) {
                        audioNodes.effects.reverb.connect(lastNode);
                        lastNode = audioNodes.effects.reverb;
                    }
                    
                    if (selectedEffects.includes('filter')) {
                        audioNodes.effects.filter.connect(lastNode);
                        lastNode = audioNodes.effects.filter;
                    }
                    
                    if (selectedEffects.includes('delay')) {
                        const delayMix = audioContext.createGain();
                        delayMix.gain.value = 0.3;
                        
                        lastNode.connect(delayMix);
                        lastNode.connect(audioNodes.mainGain);
                        
                        audioNodes.effects.delay.connect(delayMix);
                        delayMix.connect(lastNode);
                    }
                    
                    if (selectedEffects.includes('chorus')) {
                        lastNode.connect(audioNodes.effects.chorus.delay);
                        lastNode.connect(audioNodes.mainGain);
                    }
                    
                    if (selectedEffects.includes('phaser')) {
                        audioNodes.effects.phaser.output.connect(lastNode);
                        lastNode = audioNodes.effects.phaser.input;
                    }
                    
                    if (selectedEffects.includes('flanger')) {
                        audioNodes.effects.flanger.output.connect(lastNode);
                        lastNode = audioNodes.effects.flanger.input;
                    }
                    
                    // Aplicar estilo de interpretación
                    let noteDuration = duration;
                    let attackTime = 0.01;
                    let releaseTime = noteDuration * 0.8;
                    
                    switch(style) {
                        case 'arpeggio':
                            noteDuration = duration * 0.7;
                            break;
                        case 'staccato':
                            noteDuration = duration * 0.3;
                            releaseTime = noteDuration * 0.5;
                            break;
                        case 'legato':
                            attackTime = 0.1;
                            releaseTime = noteDuration * 0.5;
                            break;
                        case 'random':
                            noteDuration = duration * (0.5 + Math.random() * 0.7);
                            attackTime = 0.01 + Math.random() * 0.1;
                            releaseTime = noteDuration * (0.5 + Math.random() * 0.4);
                            break;
                        case 'swing':
                            // Alternar duraciones para efecto swing
                            noteDuration = index % 2 === 0 ? duration * 0.7 : duration * 0.5;
                            break;
                        case 'reverse':
                            // Invertir el orden de las notas
                            const reverseIndex = totalNotes - index - 1;
                            noteDuration = duration * (0.5 + (reverseIndex / totalNotes) * 0.5);
                            break;
                    }
                    
                    if (instrument === 'piano') {
                        // Simulación de piano con múltiples osciladores
                        const now = audioContext.currentTime;
                        
                        // Oscilador principal (tono)
                        const mainOsc = audioContext.createOscillator();
                        mainOsc.type = 'triangle';
                        mainOsc.frequency.value = noteFrequencies[note];
                        
                        // Oscilador para simular el golpe (ruido)
                        const noiseOsc = audioContext.createOscillator();
                        noiseOsc.type = 'square';
                        noiseOsc.frequency.value = noteFrequencies[note] * 2;
                        
                        // Ganancia para el ruido (decae rápido)
                        const noiseGain = audioContext.createGain();
                        noiseGain.gain.setValueAtTime(0.3, now);
                        noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                        
                        // Ganancia principal
                        const pianoGain = audioContext.createGain();
                        pianoGain.gain.setValueAtTime(0, now);
                        pianoGain.gain.linearRampToValueAtTime(0.5, now + attackTime);
                        pianoGain.gain.exponentialRampToValueAtTime(0.01, now + releaseTime);
                        
                        // Conectar todo
                        mainOsc.connect(pianoGain);
                        noiseOsc.connect(noiseGain);
                        pianoGain.connect(lastNode);
                        noiseGain.connect(lastNode);
                        
                        // Iniciar
                        mainOsc.start(now);
                        noiseOsc.start(now);
                        mainOsc.stop(now + noteDuration);
                        noiseOsc.stop(now + noteDuration);
                        
                        // Guardar para poder detener
                        activeOscillators.push(mainOsc, noiseOsc);
                        
                    } else if (instrument === 'guitar') {
                        // Simulación de guitarra
                        const now = audioContext.currentTime;
                        
                        // Oscilador principal
                        const guitarOsc = audioContext.createOscillator();
                        guitarOsc.type = 'sawtooth';
                        guitarOsc.frequency.value = noteFrequencies[note];
                        
                        // Filtro para simular cuerpo de guitarra
                        const filter = audioContext.createBiquadFilter();
                        filter.type = 'bandpass';
                        filter.frequency.value = 1000;
                        filter.Q.value = 1;
                        
                        // Ganancia
                        const guitarGain = audioContext.createGain();
                        guitarGain.gain.setValueAtTime(0, now);
                        guitarGain.gain.linearRampToValueAtTime(0.4, now + attackTime);
                        guitarGain.gain.exponentialRampToValueAtTime(0.01, now + releaseTime);
                        
                        // Conectar
                        guitarOsc.connect(filter);
                        filter.connect(guitarGain);
                        guitarGain.connect(lastNode);
                        
                        // Iniciar
                        guitarOsc.start(now);
                        guitarOsc.stop(now + noteDuration);
                        
                        activeOscillators.push(guitarOsc);
                        
                    } else if (instrument === 'strings') {
                        // Simulación de cuerdas
                        const now = audioContext.currentTime;
                        
                        // Osciladores múltiples para simular sección de cuerdas
                        const osc1 = audioContext.createOscillator();
                        osc1.type = 'sine';
                        osc1.frequency.value = noteFrequencies[note];
                        
                        const osc2 = audioContext.createOscillator();
                        osc2.type = 'sine';
                        osc2.frequency.value = noteFrequencies[note] * 2;
                        
                        const osc3 = audioContext.createOscillator();
                        osc3.type = 'sine';
                        osc3.frequency.value = noteFrequencies[note] * 0.5;
                        
                        // Ganancia
                        const stringsGain = audioContext.createGain();
                        stringsGain.gain.setValueAtTime(0, now);
                        stringsGain.gain.linearRampToValueAtTime(0.3, now + 0.5);
                        stringsGain.gain.exponentialRampToValueAtTime(0.01, now + noteDuration * 1.5);
                        
                        // Conectar
                        osc1.connect(stringsGain);
                        osc2.connect(stringsGain);
                        osc3.connect(stringsGain);
                        stringsGain.connect(lastNode);
                        
                        // Iniciar
                        osc1.start(now);
                        osc2.start(now);
                        osc3.start(now);
                        osc1.stop(now + noteDuration * 1.5);
                        osc2.stop(now + noteDuration * 1.5);
                        osc3.stop(now + noteDuration * 1.5);
                        
                        activeOscillators.push(osc1, osc2, osc3);
                        
                    } else if (instrument === 'synth') {
                        // Sintetizador futurista
                        const now = audioContext.currentTime;
                        
                        // Oscilador principal
                        const osc = audioContext.createOscillator();
                        osc.type = 'sawtooth';
                        osc.frequency.value = noteFrequencies[note];
                        
                        // LFO para modulación
                        const lfo = audioContext.createOscillator();
                        lfo.frequency.value = 5;
                        
                        const lfoGain = audioContext.createGain();
                        lfoGain.gain.value = 20;
                        
                        // Filtro con envolvente
                        const filter = audioContext.createBiquadFilter();
                        filter.type = 'lowpass';
                        filter.frequency.value = 2000;
                        
                        const filterEnvelope = audioContext.createGain();
                        filterEnvelope.gain.setValueAtTime(2000, now);
                        filterEnvelope.gain.exponentialRampToValueAtTime(500, now + noteDuration);
                        
                        // Ganancia
                        const synthGain = audioContext.createGain();
                        synthGain.gain.setValueAtTime(0, now);
                        synthGain.gain.linearRampToValueAtTime(0.4, now + 0.05);
                        synthGain.gain.exponentialRampToValueAtTime(0.01, now + noteDuration);
                        
                        // Conectar
                        lfo.connect(lfoGain);
                        lfoGain.connect(osc.frequency);
                        
                        osc.connect(filter);
                        filterEnvelope.connect(filter.frequency);
                        filter.connect(synthGain);
                        synthGain.connect(lastNode);
                        
                        // Iniciar
                        osc.start(now);
                        lfo.start(now);
                        osc.stop(now + noteDuration);
                        lfo.stop(now + noteDuration);
                        
                        activeOscillators.push(osc, lfo);
                        
                    } else if (instrument === 'flute') {
                        // Simulación de flauta
                        const now = audioContext.currentTime;
                        
                        // Oscilador principal
                        const osc = audioContext.createOscillator();
                        osc.type = 'sine';
                        osc.frequency.value = noteFrequencies[note];
                        
                        // LFO para vibrato
                        const vibrato = audioContext.createOscillator();
                        vibrato.frequency.value = 6;
                        
                        const vibratoGain = audioContext.createGain();
                        vibratoGain.gain.value = 2;
                        
                        // Ganancia con envolvente
                        const fluteGain = audioContext.createGain();
                        fluteGain.gain.setValueAtTime(0, now);
                        fluteGain.gain.linearRampToValueAtTime(0.3, now + 0.2);
                        fluteGain.gain.exponentialRampToValueAtTime(0.01, now + noteDuration * 1.2);
                        
                        // Conectar
                        vibrato.connect(vibratoGain);
                        vibratoGain.connect(osc.frequency);
                        
                        osc.connect(fluteGain);
                        fluteGain.connect(lastNode);
                        
                        // Iniciar
                        osc.start(now);
                        vibrato.start(now);
                        osc.stop(now + noteDuration * 1.2);
                        vibrato.stop(now + noteDuration * 1.2);
                        
                        activeOscillators.push(osc, vibrato);
                        
                    } else if (instrument === 'trumpet') {
                        // Simulación de trompeta
                        const now = audioContext.currentTime;
                        
                        // Osciladores múltiples para simular timbre
                        const osc1 = audioContext.createOscillator();
                        osc1.type = 'sawtooth';
                        osc1.frequency.value = noteFrequencies[note];
                        
                        const osc2 = audioContext.createOscillator();
                        osc2.type = 'square';
                        osc2.frequency.value = noteFrequencies[note] * 2;
                        
                        // Filtro para suavizar
                        const filter = audioContext.createBiquadFilter();
                        filter.type = 'lowpass';
                        filter.frequency.value = 2000;
                        filter.Q.value = 1;
                        
                        // Ganancia con envolvente
                        const trumpetGain = audioContext.createGain();
                        trumpetGain.gain.setValueAtTime(0, now);
                        trumpetGain.gain.linearRampToValueAtTime(0.4, now + 0.05);
                        trumpetGain.gain.exponentialRampToValueAtTime(0.01, now + noteDuration);
                        
                        // Conectar
                        osc1.connect(filter);
                        osc2.connect(filter);
                        filter.connect(trumpetGain);
                        trumpetGain.connect(lastNode);
                        
                        // Iniciar
                        osc1.start(now);
                        osc2.start(now);
                        osc1.stop(now + noteDuration);
                        osc2.stop(now + noteDuration);
                        
                        activeOscillators.push(osc1, osc2);
                        
                    } else if (instrument === 'bass') {
                        // Simulación de bajo
                        const now = audioContext.currentTime;
                        
                        // Oscilador principal
                        const osc = audioContext.createOscillator();
                        osc.type = 'sine';
                        osc.frequency.value = noteFrequencies[note] * 0.5; // Una octava más baja
                        
                        // Ruido para simular el golpe de cuerda
                        const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.1, audioContext.sampleRate);
                        const noiseData = noiseBuffer.getChannelData(0);
                        
                        for (let i = 0; i < noiseData.length; i++) {
                            noiseData[i] = Math.random() * 2 - 1;
                        }
                        
                        const noiseSource = audioContext.createBufferSource();
                        noiseSource.buffer = noiseBuffer;
                        
                        const noiseFilter = audioContext.createBiquadFilter();
                        noiseFilter.type = 'highpass';
                        noiseFilter.frequency.value = 100;
                        
                        const noiseGain = audioContext.createGain();
                        noiseGain.gain.setValueAtTime(0.2, now);
                        noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                        
                        // Ganancia principal
                        const bassGain = audioContext.createGain();
                        bassGain.gain.setValueAtTime(0, now);
                        bassGain.gain.linearRampToValueAtTime(0.5, now + 0.1);
                        bassGain.gain.exponentialRampToValueAtTime(0.01, now + noteDuration);
                        
                        // Conectar
                        osc.connect(bassGain);
                        noiseSource.connect(noiseFilter);
                        noiseFilter.connect(noiseGain);
                        bassGain.connect(lastNode);
                        noiseGain.connect(lastNode);
                        
                        // Iniciar
                        osc.start(now);
                        noiseSource.start(now);
                        osc.stop(now + noteDuration);
                        noiseSource.stop(now + 0.1);
                        
                        activeOscillators.push(osc, noiseSource);
                    } else {
                        // Instrumentos básicos
                        oscillator = audioContext.createOscillator();
                        oscillator.type = instrument;
                        
                        gainNode = audioContext.createGain();
                        gainNode.gain.value = 0.3;
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(lastNode);
                        
                        oscillator.frequency.value = noteFrequencies[note];
                        
                        // Envelope
                        const now = audioContext.currentTime;
                        gainNode.gain.setValueAtTime(0, now);
                        gainNode.gain.linearRampToValueAtTime(0.3, now + attackTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, now + releaseTime);
                        
                        oscillator.start(now);
                        oscillator.stop(now + noteDuration);
                        
                        activeOscillators.push(oscillator);
                    }
                    
                    // Visualización
                    visualizeNote(note, index, totalNotes);
                    highlightNote(note);
                    
                    // Actualizar información de reproducción
                    elements.currentNote.textContent = `Nota actual: ${note} (${Math.round(noteFrequencies[note])} Hz) | Estilo: ${style}`;
                    elements.playbackInfo.classList.add('active');
                    setTimeout(() => {
                        elements.playbackInfo.classList.remove('active');
                    }, 300);
                    
                    // Limpiar después de la duración
                    setTimeout(() => {
                        if (oscillator) oscillator.disconnect();
                        if (gainNode) gainNode.disconnect();
                        resolve();
                    }, noteDuration * 1000);
                });
            }
            
            // Resaltar nota en el teclado
            function highlightNote(note) {
                // Quitar resaltado previo
                document.querySelectorAll('.white-key.active, .black-key.active').forEach(key => {
                    key.classList.remove('active');
                });
                
                // Resaltar nueva tecla
                const key = document.querySelector(`[data-note="${note}"]`);
                if (key) {
                    key.classList.add('active');
                    
                    // Quitar resaltado después de un tiempo
                    setTimeout(() => {
                        key.classList.remove('active');
                    }, 300);
                }
            }
            
            // Visualizar nota
            function visualizeNote(note, index, totalNotes) {
                const visualizationType = elements.visualizationSelect.value;
                
                if (visualizationType === 'bars') {
                    const noteElement = document.createElement('div');
                    noteElement.className = 'note-bar';
                    
                    // Calcular propiedades basadas en la nota
                    const noteName = note.slice(0, -1); // Eliminar octava
                    const octave = parseInt(note.slice(-1));
                    const height = 30 + (octave - 3) * 20;
                    const left = (index / totalNotes) * 100;
                    const hue = (index * 360 / totalNotes) % 360;
                    
                    noteElement.style.left = `${left}%`;
                    noteElement.style.height = `${height}px`;
                    noteElement.style.backgroundColor = `hsl(${hue}, 80%, 60%)`;
                    noteElement.style.opacity = '0.8';
                    
                    elements.visualizer.appendChild(noteElement);
                    
                    // Animación
                    setTimeout(() => {
                        noteElement.style.opacity = '0';
                        setTimeout(() => {
                            noteElement.remove();
                        }, 1000);
                    }, 500);
                }
                
                // Añadir nota musical flotante
                if (visualizationType === 'particles' || visualizationType === 'circular') {
                    createFloatingNote(note, (index / totalNotes) * 100);
                }
                
                // Visualización tipo rollo de piano
                if (visualizationType === 'piano') {
                    const noteElement = document.createElement('div');
                    noteElement.className = 'note-bar';
                    
                    const noteName = note.slice(0, -1);
                    const isBlackKey = noteName.includes('#') || noteName.includes('b');
                    
                    const left = (index / totalNotes) * 100;
                    const width = 100 / totalNotes * 2;
                    
                    noteElement.style.left = `${left}%`;
                    noteElement.style.width = `${width}%`;
                    noteElement.style.height = isBlackKey ? '60%' : '100%';
                    noteElement.style.bottom = isBlackKey ? '40%' : '0';
                    noteElement.style.backgroundColor = isBlackKey ? '#333' : '#fff';
                    noteElement.style.border = isBlackKey ? '1px solid #222' : '1px solid #ddd';
                    noteElement.style.zIndex = isBlackKey ? '2' : '1';
                    
                    elements.visualizer.appendChild(noteElement);
                    
                    setTimeout(() => {
                        noteElement.style.opacity = '0.5';
                        setTimeout(() => {
                            noteElement.remove();
                        }, 1000);
                    }, 500);
                }
            }
            
            // Crear efecto de nota musical flotante
            function createFloatingNote(note, leftPercent) {
                const noteSymbol = document.createElement('div');
                noteSymbol.className = 'music-note';
                noteSymbol.textContent = '♪';
                noteSymbol.style.left = `${leftPercent}%`;
                noteSymbol.style.color = getNoteColor(note);
                
                if (elements.visualizationSelect.value === 'circular') {
                    noteSymbol.style.position = 'absolute';
                    noteSymbol.style.left = '50%';
                    noteSymbol.style.top = '50%';
                    noteSymbol.style.transform = 'translate(-50%, -50%)';
                    noteSymbol.style.animation = 'note-float 3s linear forwards, spin 3s linear infinite';
                }
                
                elements.visualizer.appendChild(noteSymbol);
                
                setTimeout(() => {
                    noteSymbol.remove();
                }, 3000);
            }
            
            // Obtener color basado en la nota
            function getNoteColor(note) {
                const noteColors = {
                    'C': '#e74c3c', 'C#': '#9b59b6', 'Db': '#9b59b6',
                    'D': '#3498db', 'D#': '#1abc9c', 'Eb': '#1abc9c',
                    'E': '#2ecc71', 'F': '#f1c40f',
                    'F#': '#e67e22', 'Gb': '#e67e22',
                    'G': '#d35400', 'G#': '#e84393', 'Ab': '#e84393',
                    'A': '#0984e3', 'A#': '#00b894', 'Bb': '#00b894',
                    'B': '#6c5ce7'
                };
                
                const noteName = note.replace(/[0-9]/g, '');
                return noteColors[noteName] || '#7f8c8d';
            }
            
            // Reproducir sonido de celebración
            function playCompletionSound() {
                initAudio();
                
                // Mostrar efectos visuales
                showCelebration();
                
                // Crear múltiples osciladores para un sonido rico
                const now = audioContext.currentTime;
                const duration = 3;
                
                // Sonido principal (subida)
                const mainOsc = audioContext.createOscillator();
                mainOsc.type = 'sine';
                mainOsc.frequency.setValueAtTime(440, now);
                mainOsc.frequency.exponentialRampToValueAtTime(1760, now + duration);
                
                const mainGain = audioContext.createGain();
                mainGain.gain.setValueAtTime(0.3, now);
                mainGain.gain.exponentialRampToValueAtTime(0.01, now + duration);
                
                // Sonido secundario (bajada)
                const secOsc = audioContext.createOscillator();
                secOsc.type = 'square';
                secOsc.frequency.setValueAtTime(880, now);
                secOsc.frequency.exponentialRampToValueAtTime(220, now + duration);
                
                const secGain = audioContext.createGain();
                secGain.gain.setValueAtTime(0.2, now);
                secGain.gain.exponentialRampToValueAtTime(0.01, now + duration);
                
                // Ruido para simular aplausos
                const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * duration, audioContext.sampleRate);
                const noiseData = noiseBuffer.getChannelData(0);
                
                for (let i = 0; i < noiseData.length; i++) {
                    noiseData[i] = Math.random() * 2 - 1;
                }
                
                const noiseSource = audioContext.createBufferSource();
                noiseSource.buffer = noiseBuffer;
                
                const noiseFilter = audioContext.createBiquadFilter();
                noiseFilter.type = 'bandpass';
                noiseFilter.frequency.value = 1000;
                
                const noiseGain = audioContext.createGain();
                noiseGain.gain.setValueAtTime(0.1, now);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, now + duration);
                
                // Conectar todo
                mainOsc.connect(mainGain);
                secOsc.connect(secGain);
                noiseSource.connect(noiseFilter);
                noiseFilter.connect(noiseGain);
                
                mainGain.connect(audioNodes.mainGain);
                secGain.connect(audioNodes.mainGain);
                noiseGain.connect(audioNodes.mainGain);
                
                // Iniciar
                mainOsc.start(now);
                secOsc.start(now);
                noiseSource.start(now);
                
                // Detener después de la duración
                mainOsc.stop(now + duration);
                secOsc.stop(now + duration);
                noiseSource.stop(now + duration);
                
                // Mostrar notificación
                showNotification('¡Conversión completada con éxito!');
            }
            
            // Mostrar efectos de celebración
            function showCelebration() {
                elements.completionEffect.style.display = 'block';
                
                // Crear confeti
                for (let i = 0; i < 200; i++) {
                    setTimeout(() => {
                        const confetti = document.createElement('div');
                        confetti.className = 'confetti';
                        confetti.style.left = Math.random() * 100 + 'vw';
                        confetti.style.backgroundColor = `hsl(${Math.random() * 360}, 100%, 50%)`;
                        confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
                        confetti.style.animationDuration = `${Math.random() * 3 + 2}s`;
                        confetti.style.width = `${Math.random() * 10 + 5}px`;
                        confetti.style.height = `${Math.random() * 10 + 5}px`;
                        elements.completionEffect.appendChild(confetti);
                        
                        setTimeout(() => {
                            confetti.remove();
                        }, 5000);
                    }, i * 15);
                }
                
                // Crear fuegos artificiales
                for (let i = 0; i < 30; i++) {
                    setTimeout(() => {
                        const firework = document.createElement('div');
                        firework.className = 'firework';
                        firework.style.left = Math.random() * 80 + 10 + 'vw';
                        firework.style.top = Math.random() * 50 + 10 + 'vh';
                        firework.style.color = `hsl(${Math.random() * 360}, 100%, 50%)`;
                        elements.completionEffect.appendChild(firework);
                        
                        // Crear partículas secundarias
                        for (let j = 0; j < 20; j++) {
                            setTimeout(() => {
                                const particle = document.createElement('div');
                                particle.className = 'confetti';
                                particle.style.left = firework.style.left;
                                particle.style.top = firework.style.top;
                                particle.style.backgroundColor = firework.style.color;
                                particle.style.width = '4px';
                                particle.style.height = '4px';
                                particle.style.animation = `fall ${Math.random() * 2 + 1}s linear forwards`;
                                elements.completionEffect.appendChild(particle);
                                
                                setTimeout(() => {
                                    particle.remove();
                                }, 3000);
                            }, j * 30);
                        }
                        
                        setTimeout(() => {
                            firework.remove();
                        }, 1000);
                    }, i * 100);
                }
                
                // Crear emojis flotantes
                const emojis = ['🎉', '🎊', '🎶', '🎵', '🥳', '👏', '💫', '✨', '🌟', '🎇', '🎆', '🌈'];
                for (let i = 0; i < 50; i++) {
                    setTimeout(() => {
                        const emoji = document.createElement('div');
                        emoji.className = 'emoji-effect';
                        emoji.textContent = emojis[Math.floor(Math.random() * emojis.length)];
                        emoji.style.left = Math.random() * 80 + 10 + 'vw';
                        emoji.style.animationDuration = `${Math.random() * 2 + 1}s`;
                        emoji.style.fontSize = `${Math.random() * 20 + 20}px`;
                        elements.completionEffect.appendChild(emoji);
                        
                        setTimeout(() => {
                            emoji.remove();
                        }, 3000);
                    }, i * 50);
                }
                
                // Ocultar después de 5 segundos
                setTimeout(() => {
                    elements.completionEffect.style.display = 'none';
                    elements.completionEffect.innerHTML = '';
                }, 5000);
            }
            
            // Reproducir secuencia de notas
            async function playNotes(notes, tempo, instrument) {
                isPlaying = true;
                elements.playBtn.disabled = true;
                elements.stopBtn.disabled = false;
                elements.saveBtn.disabled = true;
                
                // Calcular duración de cada nota en segundos (120 BPM = 0.5s por negra)
                const noteDuration = 60 / tempo * 0.5;
                const totalDuration = notes.length * noteDuration * 1.2; // Estimación
                
                // Actualizar estadísticas
                elements.duration.textContent = `${totalDuration.toFixed(1)}s`;
                
                // Limpiar visualizador
                elements.visualizer.innerHTML = '';
                if (elements.visualizationSelect.value === 'bars' || 
                    elements.visualizationSelect.value === 'wave' ||
                    elements.visualizationSelect.value === 'piano') {
                    elements.visualizer.innerHTML = '<div class="waveform"></div>';
                }
                
                elements.currentAction.textContent = `Reproduciendo ${notes.length} notas...`;
                
                for (let i = 0; i < notes.length; i++) {
                    if (!isPlaying) break;
                    
                    // Actualizar progreso
                    const progress = (i / notes.length) * 100;
                    
                    await playNote(notes[i], noteDuration, instrument, i, notes.length);
                    
                    // Pequeña pausa entre notas
                    if (i < notes.length - 1 && isPlaying) {
                        await new Promise(resolve => {
                            playbackTimeout = setTimeout(resolve, noteDuration * 200);
                        });
                    }
                }
                
                if (isPlaying) {
                    // Reproducir sonido de celebración
                    playCompletionSound();
                    
                    elements.currentAction.textContent = '¡Conversión completada!';
                    elements.currentNote.textContent = '';
                    
                    // Habilitar botón de guardar
                    elements.saveBtn.disabled = false;
                }
                
                isPlaying = false;
                elements.playBtn.disabled = false;
                elements.stopBtn.disabled = true;
            }
            
            // Detener reproducción
            function stopPlayback() {
                isPlaying = false;
                
                // Detener todos los osciladores
                activeOscillators.forEach(osc => {
                    try {
                        osc.stop();
                        osc.disconnect();
                    } catch(e) {
                        console.error("Error stopping oscillator:", e);
                    }
                });
                activeOscillators = [];
                
                if (playbackTimeout) {
                    clearTimeout(playbackTimeout);
                }
                
                elements.playBtn.disabled = false;
                elements.stopBtn.disabled = true;
                elements.currentAction.textContent = 'Reproducción detenida';
                elements.currentNote.textContent = '';
                
                // Mostrar notificación
                showNotification('Reproducción detenida', 2000);
            }
            
            // Event listeners
            elements.tempoSlider.addEventListener('input', function() {
                const tempo = this.value;
                elements.tempoValue.textContent = tempo;
                
                // Cambiar color basado en tempo
                const hue = 120 + (tempo - 40) * 0.9; // De verde (lento) a rojo (rápido)
                elements.tempoValue.style.backgroundColor = `hsl(${hue}, 70%, 80%)`;
                elements.tempoValue.style.color = tempo > 200 ? 'white' : 'var(--dark-color)';
            });
            
            elements.textInput.addEventListener('input', function() {
                const text = this.value;
                const charCount = text.length;
                elements.charCount.textContent = charCount;
                
                // Actualizar contador en el textarea
                document.querySelector('.char-counter').textContent = `${charCount} caracteres`;
                
                // Cambiar color del contador
                const counter = document.querySelector('.char-counter');
                if (charCount > 200) {
                    counter.style.color = '#2ecc71';
                    counter.style.fontWeight = 'bold';
                } else if (charCount > 100) {
                    counter.style.color = '#f39c12';
                    counter.style.fontWeight = 'bold';
                } else {
                    counter.style.color = '#7f8c8d';
                    counter.style.fontWeight = 'normal';
                }
                
                // Calcular complejidad del texto
                const complexity = calculateTextComplexity(text);
                elements.complexity.textContent = complexity > 0.75 ? 'Muy Alta' : 
                                               complexity > 0.5 ? 'Alta' : 
                                               complexity > 0.25 ? 'Media' : 'Baja';
            });
            
            elements.convertBtn.addEventListener('click', function() {
                const text = elements.textInput.value.trim();
                if (!text) {
                    elements.currentAction.textContent = 'Por favor ingresa algún texto';
                    showNotification('Ingresa texto para convertir', 2000);
                    return;
                }
                
                const scale = elements.scaleSelect.value;
                const notes = textToNotes(text, scale);
                currentNotes = notes;
                
                elements.playBtn.disabled = false;
                elements.noteCount.textContent = notes.length;
                elements.currentAction.textContent = `Texto convertido a ${notes.length} notas en escala ${scale}`;
                
                // Mostrar notificación
                showNotification(`Convertido a ${notes.length} notas musicales`, 2000);
                
                // Calcular estadísticas musicales
                const uniqueNotes = new Set(notes).size;
                const noteDiversity = (uniqueNotes / notes.length) * 100;
                
                // Calcular rango dinámico (diferencia entre nota más alta y más baja)
                let minOctave = 8, maxOctave = 0;
                notes.forEach(note => {
                    const octave = parseInt(note.slice(-1));
                    if (octave < minOctave) minOctave = octave;
                    if (octave > maxOctave) maxOctave = octave;
                });
                const dynamicRange = maxOctave - minOctave;
                
                elements.complexity.textContent = 
                    dynamicRange > 3 ? 'Orquestal' : 
                    noteDiversity > 70 ? 'Variada' : 
                    notes.length > 100 ? 'Extensa' : 
                    uniqueNotes < 5 ? 'Minimalista' : 'Balanceada';
            });
            
            elements.playBtn.addEventListener('click', function() {
                if (currentNotes.length === 0) {
                    elements.currentAction.textContent = 'No hay notas para reproducir';
                    showNotification('Primero convierte texto a notas', 2000);
                    return;
                }
                
                const tempo = parseInt(elements.tempoSlider.value);
                const instrument = elements.instrumentSelect.value;
                
                playNotes(currentNotes, tempo, instrument);
                
                // Mostrar notificación
                showNotification('Reproduciendo composición...', 2000);
            });
            
            elements.stopBtn.addEventListener('click', stopPlayback);
            
            elements.saveBtn.addEventListener('click', function() {
                if (currentNotes.length === 0) {
                    showNotification('Nada que guardar', 2000);
                    return;
                }
                
                // Simular guardado
                elements.saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Guardando...';
                elements.saveBtn.disabled = true;
                
                setTimeout(() => {
                    elements.saveBtn.innerHTML = '<i class="fas fa-save"></i> Guardar MIDI';
                    showNotification('Composición guardada como MIDI', 2000);
                }, 1500);
            });
            
            elements.shareBtn.addEventListener('click', function() {
                // Simular compartir
                elements.shareBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Compartiendo...';
                
                setTimeout(() => {
                    elements.shareBtn.innerHTML = '<i class="fas fa-share-alt"></i> Compartir';
                    showNotification('Enlace copiado al portapapeles', 2000);
                }, 1000);
            });
            
            elements.visualizationSelect.addEventListener('change', function() {
                elements.visualizer.innerHTML = '';
                if (this.value === 'bars' || this.value === 'wave' || this.value === 'piano') {
                    elements.visualizer.innerHTML = '<div class="waveform"></div>';
                }
            });
            
            // Modal de teoría musical
            elements.theoryBtn.addEventListener('click', function() {
                elements.theoryModal.style.display = 'block';
            });
            
            elements.closeModal.addEventListener('click', function() {
                elements.theoryModal.style.display = 'none';
            });
            
            window.addEventListener('click', function(event) {
                if (event.target === elements.theoryModal) {
                    elements.theoryModal.style.display = 'none';
                }
            });
            
            // Inicializar teclado virtual
            createKeyboard();
            
            // Mostrar mensaje de bienvenida
            setTimeout(() => {
                showNotification('¡Bienvenido al Mega Conversor Musical Pro!', 3000);
            }, 1000);
        });
    </script>
</body>
</html>